--- 
title: "Radon mapping with R"
author: "Javier Elío"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [library.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "Radon mapping concepts with examples"
---

```{r setup, include=FALSE}
# Chunk options 
  knitr::opts_chunk$set(include = TRUE,
                        echo = TRUE,
                        fig.pos = "H",
                        fig.align = "center",
                        warning = FALSE,
                        message = FALSE,
                        comment = "#>")
  options(knitr.kable.NA = "-")
  
```

# Prerequisites {-}

The data have been analysed with **R** (version `r paste(R.Version()$major, R.Version()$minor, sep = ".")`) and **Rstudio** (versio `r rstudioapi::versionInfo()$version`), and the book has been created with **bookdown** package. The required packages are automatically checked and installed if needed from CRAN.

```{r, results='hide'}

# Create an auxiliary function for checking if a package is installed,
# install it if it is not, and load the package
# (based on https://gist.github.com/stevenworthington/3178163) 
  ipak <- function(pkg){
    new_pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new_pkg)) 
      install.packages(new_pkg,
                       dependencies = TRUE,
                       repos = "http://cran.us.r-project.org")
    sapply(pkg, require, character.only = TRUE)
  }
  # List of packages 
  pkg <- c("tidyverse",
           "sf", 
           "sp", 
           "gstat"
           )
  # Check and install
  ipak(pkg)
  
```

```{r}

# You may also need to install the following packages

  #install.packages(c("MASS", "StatDA", "NADA", "truncnorm", "units", "leaflet", "ggspatial", "gridExtra", "rgdal"))

```

```{r, include=FALSE}

# automatically create a bib database for R packages
knitr::write_bib(x = c(.packages()), file = 'packages.bib')

```

## R session {-}

```{r R-session, echo = FALSE}
sessionInfo()
```

<!--chapter:end:index.Rmd-->

# Read data 

## Administrative divisions (

I got Lithuania from www.gadm.org, but you may download the administrative areas of other countries  

```{r adm-units}

  Country <- readRDS(url("https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_0_sf.rds"))
  County  <- readRDS(url("https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_1_sf.rds"))
  Muni    <- readRDS(url("https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_2_sf.rds"))
  
```

## Grids 10 x 10 km 
  
Download from https://www.eea.europa.eu/data-and-maps/data/eea-reference-grids-2
  
```{r grids-EEA, cache=TRUE}
EEA_Ref_grid_URL <- "https://www.eea.europa.eu/data-and-maps/data/eea-reference-grids-2/gis-files/lithuania-shapefile/at_download/file.zip"
  temp  <- tempfile()
  temp2 <- tempfile()
  download.file(EEA_Ref_grid_URL, temp)
  unzip(zipfile = temp, exdir = temp2)
  Grids_10km <- read_sf(file.path(temp2, "lt_10km.shp"))
  unlink(c(temp, temp2))
  
  Grids_10km$Id <- seq(1, length(Grids_10km$CELLCODE), 1)   # Add new column with "Id"
  Grids_10km$Id <- as.factor(Grids_10km$Id)                 # Stored as a vector of integer values
  st_crs(Grids_10km)                                        # Coordinate Reference System
  st_crs(Country)                                           # Coordinate Reference System
  Grids_10km <- Grids_10km %>% st_transform(4326)           # Trandform coordinate system (from  EPSG: 3035 to EPSG: 4326)
  st_crs(Grids_10km)                                        # Coordinate Reference System 
  st_crs(Country)                                           # Coordinate Reference System 
  Grids_10km <- st_intersection(Grids_10km, Country)        # Grids in the country
```


```{r plot-grids}

plot(Grids_10km["Id"])
   
```
    
## Make our own grid (e.g. 0.1 x 0.1 degrees)

```{r make-grids}

# Make regular grids (0.1 x 0.1)
  Grids <- Country %>% 
    st_make_grid(cellsize = 0.1, what = "polygons") %>%
    st_sf() %>%
    st_intersection(Country) %>%
    # Name grids as "g001", "g002"
    mutate(ID = paste0("g", stringr::str_pad(seq(1, nrow(.), 1), 3, pad = "0")))

# Centroid of the grid
  SPDF  <- st_centroid(Grids) 

```

```{r}
  
  plot(Country["NAME_0"], reset = F, main = "Lithuania: cells 0.1x0.1 degrees")
  plot(Grids, add = T, border = 2)
  plot(SPDF, add = T, col = "blue")
   
```

## Geology 1:5M 

Download from [BGR](https://produktcenter.bgr.de/terraCatalog/DetailResult.do?fileIdentifier=9FD6624C-0AA7-46D4-9DA3-955E558CD5F1) [@Asch2003] 
```{r BG, cache=TRUE}

  IGME5000_url <- "https://download.bgr.de/bgr/Geologie/IGME5000/shp/IGME5000.zip" 
  temp <- tempfile()
  temp2 <- tempfile()
  download.file(IGME5000_url, temp)
  unzip(zipfile = temp, exdir = temp2)
  IGME5000 <- read_sf(file.path(temp2, "europe/data/IGME5000_europeEPSG3034shp_geology_poly_v01.shp"))
  unlink(c(temp, temp2))
    
  st_crs(IGME5000)
  st_crs(Country)
  
  IGME5000 <- IGME5000 %>%
    st_transform(4326) %>%
    st_intersection(Country)
  st_crs(IGME5000)
  plot(IGME5000["AgeName"])
```

## Study area 

I will focus the data analysis in a region of of 1x1 degrees

```{r study-area}

#  First: build a rectangle 
  Area <- matrix(NA, ncol = 2, nrow = 4)
  Area <- as.data.frame(Area)
  names(Area) <- c("X","Y")
  Area[1,] <- c(23,55)
  Area[2,] <- c(23,56)
  Area[3,] <- c(24,56)
  Area[4,] <- c(24,55)
  
  coordinates(Area) <- ~X+Y
  Area <- rbind(Area,Area[1,])
  Area <- Polygons(list(Polygon(Area)),ID="Area")
  Area <- SpatialPolygons(list(Area))
  Area <- as(Area, "sf")
  st_crs(Area) <- st_crs(Country)
  
  plot(Country["NAME_0"], axes = TRUE, reset = F)
  plot(Area, col = "blue", add = T)
  
# Second: intersect Area with all the data
  Country <- st_intersection(Country, Area)
  County <- st_intersection(County, Area)
  Muni <- st_intersection(Muni, Area)
  Grids_10km <- st_intersection(Grids_10km, Area)
  IGME5000 <- st_intersection(IGME5000, Area)

```

## Indoor radon (simulated data) 

Please be aware that I am using SIMULATED data, and therefore data interpretation is NOT real. Any coincidence with a real case (i.e. Lithuania) is casual. Data are only useful for training purpose, you may need to read your own data for data interpretation.  
  
```{r sim-InRn, cache=TRUE}

  set.seed(1)  # Make the simulation reproducible
  
# Radom points in the study area 
  N <- 1000
  X <- runif(N,23.0001,23.9999)
  Y <- runif(N,55.0001,55.9999)
  points <- cbind(X,Y)
  points <- as.data.frame(points)
  coordinates(points) <- ~X+Y
  proj4string(points) <- CRS("EPSG:4326")
  points <- as(points, "sf")
  points <- st_intersection(points, Country)
  points <- as_Spatial(points)                

# define the gstat object (spatial model)
  library(gstat)
  g_dummy <- gstat(formula = z ~ 1,
                   locations = ~ X + Y,
                   dummy = T,
                   beta = 3,
                   model = vgm(psill = 1.5, 
                               model = "Exp",
                               range = 10,
                               nugget = 0.5),
                   nmax  = 100)
  
# Simulations based on the gstat object
  points <- predict(g_dummy, newdata = points, nsim = 1)
  points$Rn    <- exp(points$sim1)
  
# Final result: Simulated indoor radon dataset (InRn) in Bq m-3
  InRn <- points[,"Rn"]
  
# Detection Limit (DL): 10 Bq m-3 (replaced by half of the Limit of Detection)
  InRn[InRn$Rn <= 10,] <- 5
  InRn <- as(InRn, "sf") %>% 
    st_transform(crs = "EPSG:4326")
  
```
 

<!--chapter:end:01-data.Rmd-->

# Exploratory data analysis 

## Histogram (Rn)
```{r hist}

hist(InRn$Rn,
       prob = T,
       col = "red",
       breaks = 10, 
       main = "Histogram Indoor Radon",
       xlab = expression("Rn " * "[Bq" * m^-3 * "]"))
  StatDA::qqplot.das(InRn$Rn,
             distribution = "norm",
             col = 1, envelope = 0.95, 
             datax = T,
             main = "Q-Q plot (InRn)")
  
```


```{r boxcox}
## Box-Cox transformation ----
  BCT <- MASS::boxcox(InRn$Rn ~ 1, lambda = seq(-1, 1, 1/100))
  title("Box-Cox Transformation")
  BCT <- as.data.frame(BCT)
  # lambda <- BCT[BCT$y == max(BCT$y), ]$x # -0.17
  # InRn$BCT <- (InRn$Rn^lambda-1)/lambda
  lambda <- 0
  InRn$LogRn <- log(InRn$Rn)
```


```{r hist-log}
## Histogram (logRn) ----
  hist(InRn$LogRn,
       col = "red",
       breaks = 30,
       prob = T,
       main = "Histogram Indoor Radon",
       xlab = expression("LogRn " * "[Bq" * m^-3 * "]"))
  StatDA::qqplot.das(InRn$LogRn, distribution = "norm", col = 1, envelope = 0.95,datax=T, main = "Q-Q plot (log InRn)")
```


```{r ROS}
## ROS: “ROBUST” IMPUTATION METHOD ----
  DL <- 10 
  InRn_DL <- InRn
  InRn_DL$Rn_Cen <- "FALSE"
  InRn_DL[InRn_DL$Rn <= DL,]["Rn_Cen"] <- "TRUE"  
  InRn_DL$Rn_Cen <- as.logical(InRn_DL$Rn_Cen) 
  ROS <- NADA::ros(InRn_DL$Rn, InRn_DL$Rn_Cen, forwardT = "log")
  ROS <- as.data.frame(ROS)
  # Replace Dl by the modeled values
  InRn_DL[InRn_DL$Rn_Cen == "TRUE",]["Rn"] <- ROS[ROS$censored == "TRUE",]["modeled"]
  InRn_DL$LogRn <- log(InRn_DL$Rn)
```


```{r qqplot}
## q-q plots ----
  par(mfrow=c(1,2))  
  StatDA::qqplot.das(InRn$LogRn,
             distribution = "norm",
             col = 1,
             envelope = 0.95,
             datax = T,
             main = "Original data") 
  StatDA::qqplot.das(InRn_DL$LogRn,
             distribution = "norm",
             col = 1,
             envelope = 0.95,
             datax = T,
             main = "After ROS")
  
  mean(InRn$Rn)
  sd(InRn$Rn)  
  exp(mean(InRn$LogRn))
  exp(sd(InRn$LogRn))
  RL <- 200 # Bq m-3
  100*(1 - pnorm(log(RL), mean = mean(InRn$LogRn), sd = sd(InRn$LogRn)))
  
  mean(InRn_DL$Rn)
  sd(InRn_DL$Rn)  
  exp(mean(InRn_DL$LogRn))
  exp(sd(InRn_DL$LogRn))
  100*(1-pnorm(log(RL), mean = mean(InRn_DL$LogRn), sd = sd(InRn_DL$LogRn)))
```


```{r hist-log-DL}
## Histogram (logRn) ----
  par(mfrow=c(1,2)) 
  hist(InRn$LogRn,
       col = "red",
       breaks = 30,
       prob = T,
       ylim = c(0, 0.5),
       main = "Origical data",
       xlab = expression("LogRn " * "[Bq" * m^-3 * "]"))
  hist(InRn_DL$LogRn,
       col = "red",
       breaks = 30,
       prob = T,
       ylim = c(0, 0.5),
       main = "After ROS",
       xlab = expression("LogRn " * "[Bq" * m^-3 * "]"))
```


```{r hist-box-qqplot}
## Histogram, boxplot, q-q plot ----
  par(mfrow = c(1,3))
  hist(InRn_DL$LogRn,
       col = "red",
       breaks = 30,
       prob = T,
       main = "Histogram",
       xlab = expression("LogRn " * "[Bq" * m^-3 * "]"))
  lines(density(InRn_DL$LogRn), lwd = 1)
  
  boxplot(InRn_DL$LogRn,
          notch = TRUE,
          col=2,
          varwidth = TRUE,
          main = "Boxplot",
          ylab = "Lognormal transformation",
          xlab = expression("LogRn " * "[Bq" * m^-3 * "]"))
  
  StatDA::qqplot.das(InRn_DL$LogRn,
             distribution = "norm",
             col = 1,
             envelope = 0.95,
             datax = T,
             ylab = "Observed Value",
             xlab = "Expected Normal Value",
             main = ("Normal Q-Q plot"),
             line = "quartiles",
             pch = 3,
             cex = 0.7,
             xaxt = "s")
```

## Spatial distribution
```{r spatial}
## Plot InRn measurements in Bq/m3 (with ggplot2) ----
  P_Rn <- ggplot() +
    geom_sf(data = Grids_10km) + 
    geom_sf(data = InRn_DL, aes(color = Rn)) + 
    scale_color_gradient(name = "Bq/m3", low = "blue", high = "red") +
    ggtitle("Indoor radon measurements (Simulated)")
  P_Rn
```


```{r InRN-sim}
## Change intervale in the Rn scale ----
  breaks <- c(0, 50, 100, 200, 300, 500, max(InRn_DL$Rn))
  InRn_DL <- InRn_DL %>% mutate(brks = cut(Rn, breaks, include.lowest = T, right = F))
  cols <- colorRampPalette(c("blue", "red"))(6)
  # cols <- terrain.colors(6)
  # cols <- heat.colors(6, alpha = 1)
  # cols <- colorRampPalette(c("yellow", "red"))(6)
  P_Rn_brks <- ggplot() +
    geom_sf(data = Grids_10km) +
    geom_sf(data = InRn_DL, aes(fill = brks, color = brks)) + 
    scale_fill_manual(name = "Bq/m3", values = cols, guide = guide_legend(reverse = TRUE)) +
    scale_color_manual(name = "Bq/m3", values = cols, guide = guide_legend(reverse = TRUE)) +
    ggtitle("Indoor radon measurements (Simulated)") 
  P_Rn_brks
```


```{r plot-HRL}
## Plot if Rn is higher than Reference level (1) or not (0) ----
  # Transform InRn to: 1 if Rn >= RL or 0 if Rn < RL ("Case")   
    RL <- 200 # Bq m-3
    InRn_DL <- InRn_DL %>% mutate(Case = as.factor(ifelse(Rn >= 200, yes = 1, no = 0))) 

    P_Cases <- ggplot() +
      geom_sf(data = Grids_10km) + 
      geom_sf(data = InRn_DL, aes(fill = Case, color = Case)) +
      scale_fill_manual( name = "Bq/m3", labels = c("< 200",">= 200"), values = c("lightgreen", "red")) +
      scale_color_manual(name = "Bq/m3", labels = c("< 200",">= 200"), values = c("lightgreen", "red")) +
      # theme(legend.position = "none") +
      ggtitle("Indoor radon measurements (Simulated)")  
    P_Cases
```


```{r kernel}
## Kernel density plots ----
  # The resulting density map is “noisier” for small bandwidth (h)
  # and “smoother” for large bandwidth (h).  
  # A rule-of-thumb for an optimal value is h ≈ max(sx, sy)*0.7*n^-0.2 
  # where n is the number of points, 
  # and sx and sy the standard deviations of x- and y- coordinates of the points
  # See printed version of the EU Atlas for further information (in progress)
  # 2.4. Statistics, measurements, maping (part wirtten by P. Bossew) 
 
  # All dwelling sampled (e.g. for detecting possible clusters; avoid overplotting)
    H <- st_coordinates(InRn_DL)
    h <- max(sd(H[,"X"]), sd(H[,"Y"])) * 0.7 * nrow(H)^-0.2
    KP_all <- InRn_DL %>% 
      st_coordinates() %>%
      as_tibble() %>%
      ggplot() + 
      geom_sf(data = Grids_10km) +
      stat_density_2d(aes(X, Y, fill = ..level.., alpha = ..level..),
                      h = h,
                      geom = "polygon") + 
      scale_fill_distiller(palette = "Spectral") +
      theme(legend.position = "none") +
      #geom_sf(data = InRn_DL, size = .1) +
      ggtitle("Kernel density plots (all data)") +
      labs(x = "", y = "")
    KP_all
```


```{r kernel-HRL}
# Only dwellings with InRn > RL (cases == 1)
    H <- st_coordinates(filter(InRn_DL, Case == 1))
    h <- max(sd(H[,"X"]), sd(H[,"Y"])) * 0.7 * nrow(H)^-0.2
    KP_Cases <- InRn_DL %>% filter(Case == 1) %>%
      st_coordinates() %>%
      as_tibble() %>%
      ggplot() + 
      geom_sf(data = Grids_10km) +
      stat_density_2d(aes(X, Y, fill = ..level.., alpha = ..level..),
                      h = h,
                      geom = "polygon") + 
      scale_fill_distiller(palette = "Spectral") +
      theme(legend.position = "none") +
      geom_sf(data = filter(InRn_DL, Case == 1), size = .1) +
      ggtitle("Kernel density plots (InRn >= 200 Bq/m3)") +
      labs(x = "", y = "")
    KP_Cases
```


```{r kernel-LRL}
# Only dwellings with InRn < RL (cases)
    H <- st_coordinates(filter(InRn_DL, Case == 0))
    h <- max(sd(H[,"X"]), sd(H[,"Y"])) * 0.7 * nrow(H)^-0.2
    KP_No_Cases <- InRn_DL %>% filter(Case == 0) %>%
      st_coordinates() %>%
      as_tibble() %>%
      ggplot() + 
      geom_sf(data = Grids_10km) +
      stat_density_2d(aes(X, Y, fill = ..level.., alpha = ..level..),
                      h = h,
                      geom = "polygon") + 
      scale_fill_distiller(palette = "Spectral") +
      theme(legend.position = "none") +
      geom_sf(data = filter(InRn_DL, Case == 0), size = .1) +
      ggtitle("Kernel density plots (InRn < 200 Bq/m3)") +
      labs(x = "", y = "")
    KP_No_Cases
```


```{r kernel-both} 
# Plot two (or more) figures in one
    library(gridExtra)
    grid.arrange(KP_No_Cases, KP_Cases, nrow = 2)
    grid.arrange(KP_No_Cases, KP_Cases, nrow = 1)
```


```{r INRn-BG}
# InRn vs Geologia ----
  P_BG <- ggplot() +
      geom_sf(data = Country) + 
      geom_sf(data = IGME5000,  aes(fill = AgeName), colour = NA) + 
      geom_sf(data = InRn_DL, aes(), colour = 1, cex = 0.8) + 
      scale_color_gradient(low = "blue", high = "red") +
      ggtitle("Geology 1:1M") 
  P_BG
```


```{r INRn-BG-int}
## Intersect ----
  InRn_DL_BG <- st_intersection(InRn_DL, IGME5000)
```


```{r INRn-BG-boxplot}
## Boxplots ----
  par(mar = c(9,5,3,0.5), oma = c(0, 0.5, 0.5, 0.5), mfrow = c(1,1))
  boxplot(LogRn ~ AgeName, InRn_DL_BG, col = 2, 
          varwidth = TRUE,
          notch = T,
          las = 2,
          ylab = expression("LogRn " * "[Bq" * m^-3 * "]"),
          xlab = "",
          main = "Geology (AgeName)")
```


```{r INRn-BG-ANOVA}
# ANOVA ----
  lm_BG <- lm(LogRn ~ AgeName, InRn_DL_BG)
  summary(lm_BG)
  anova(lm_BG)
  
```


<!--chapter:end:02-EDA.Rmd-->

# Summary statistics

```{r sum-stat}

  ## InRn by grids of 10 x 10 km (summry: N, AM, SD, GM, GSD) ----
  InRn_DL <- st_intersection(InRn_DL, Grids_10km) 
  str(InRn_DL)
  InRn_DL$Case <- as.numeric(as.character(InRn_DL$Case))
  
  InRn_Summary_Grids10km <- InRn_DL %>% 
    group_by(Id) %>% 
    summarize(N = n(),
              Case = sum(Case),
              AM = mean(Rn),
              SD = sd(Rn),
              GM = exp(mean((LogRn))),
              GSD = exp(sd(LogRn)),
              MIN = min(Rn),
              MAX = max(Rn))  
  
  ## Add summary to grids of 10x10 km ----
  Grids_10km_Sum <- left_join(Grids_10km %>% as.data.frame(), InRn_Summary_Grids10km %>% as.data.frame(), by = "Id")
  Grids_10km_Sum <- Grids_10km_Sum %>% 
    st_sf(sf_column_name = "geometry.x") %>% 
    mutate(N = replace_na(N, 0))
  summary(Grids_10km_Sum)
  
  ## Plot number of data in each grid cell ----
  cols <- colorRampPalette(c("blue", "red"))(6)
  P_Grids10km_N <- ggplot() +
    geom_sf(data = Country) + 
    geom_sf(data = Grids_10km_Sum, aes(fill = N)) + 
    scale_fill_gradient(low = "blue", high = "red") +
    ggtitle("Number of data")
  P_Grids10km_N
  
  ## Plot arithmetic mean ----
  max(Grids_10km_Sum$AM, na.rm = T)
  breaks <- c(0, 25, 50, 75, 100, 200, max(Grids_10km_Sum$AM, na.rm = T))
  Grids_10km_Sum <- Grids_10km_Sum %>% mutate(AM_brks = cut(AM, breaks, include.lowest = T, right = F))
  cols <- colorRampPalette(c("blue", "red"))(6)
  P_Grids10km_AM <- ggplot() +
    geom_sf(data = Country) + 
    geom_sf(data = Grids_10km_Sum, aes(fill = AM_brks)) + 
    scale_fill_manual(name = "Bq/m3", values = cols, guide = guide_legend(reverse = TRUE)) +
    ggtitle("Arithmetic mean")
  P_Grids10km_AM
  
  ## Probabilistic maps ----  
  # Probability of having an indoor radon concentration above the national reference level (e.g. RL = 200 Bq m-3)
  # Based solely on the indoor radon measurements in each grid of 10x10 km,
  # and assuming data independence and lognormality
  str(Grids_10km_Sum)
  
  # 1st: estimated Prob[InRn > 200 Bq m-3]
  RL <- 200
  Grids_10km_Sum <- Grids_10km_Sum %>%
    mutate(Prob = 100*(1-pnorm(log(RL), mean = log(GM), sd = log(GSD)))) 
  
  # 2nd: Replace values in grids with less than n data (i.e. N < 5) by a modeled value
  # Generate the points for the interpolation (centroid)
  DCen <- st_centroid(Grids_10km_Sum)
  # Inverse distance weighted (IDW) interpolation
  Prob_IDW <- idw(Prob ~ 1, filter(DCen, N > 5),
                  newdata = filter(DCen, N <= 5),
                  nmax = 10,
                  idp = 2 )
  # Replace values by the modeled values
  Grids_10km_Sum <- Grids_10km_Sum %>% mutate(Prob = replace(Prob, N <= 5, Prob_IDW$var1.pred))
  
  # Plot maps
  breaks <- c(0, 1, 5, 10, 20, 30, max(Grids_10km_Sum$Prob))
  Grids_10km_Sum <- Grids_10km_Sum %>% mutate(Prob_brks = cut(Prob, breaks, include.lowest = T, right = F))
  cols <- colorRampPalette(c("blue", "red"))(6)
  P_Grids10km_Prob <- ggplot() +
    geom_sf(data = Country) + 
    geom_sf(data = Grids_10km_Sum, aes(fill = Prob_brks)) + 
    scale_fill_manual(name = "%", values = cols, guide = guide_legend(reverse = TRUE)) +
    ggtitle("Prob[InRn > 200 Bq m-3]")
  P_Grids10km_Prob
    
```


<!--chapter:end:03-summary-statistics.Rmd-->

# Interpolation

## Prediction by grids of 0.015 x 0.015 degrees 
```{r pred-grids}

InRn_Pred <- st_make_grid(Country, cellsize = .015, what = "polygons")
InRn_Pred <- st_sf(InRn_Pred)
SPDF <- st_centroid(InRn_Pred) # predict in the center of the grid 

plot(InRn_Pred, reset = F)
plot(SPDF, add = T, col = 2, pch = 16, cex = 0.7)
```

## Inverse distance weighted interpolation (IDW) 

```{r IDW-icp}
### Optimal idp (10 k-fold Croos Validation) ----
data <- InRn_DL
res <- numeric()
IDP_RMSE <- numeric()
idp <- seq(1,4,0.25)
k <- 10
folds <- sample(x = 1:k, size = length(data$Rn), replace = TRUE)
CV <- matrix(NA,length(idp),2)
for (j in 1:length(idp)) {
  for (i in 1:k) {
    m_model <- data[folds != i, ]
    m_valid <- data[folds == i, ]
    m_valid_pred <- idw(Rn ~ 1 , m_model, m_valid,
                        nmax = 100,
                        maxdist = 40,
                        nmin = 5,
                        idp = idp[j])
    res  <- m_valid$Rn - m_valid_pred$var1.pred 
    IDP_RMSE[i] <- sqrt(mean(res^2))
  } 
  CV[j,1] <- idp[j]
  CV[j,2] <- sqrt(mean(IDP_RMSE^2))
}
CV <- as.data.frame(CV)
names(CV) <- c("idp","RSME")

plot(RSME ~ idp, CV)
lines(RSME ~ idp, CV, col = 2)
axis(1, labels = F, at = seq(0,10,0.5))
abline(v = seq(0,4,0.25), lty = 2, lwd = 1.5, col="gray")
abline(h = seq(100,200,2), lty = 2, lwd = 1.5, col = "gray")
title("10-fold cross-validation")
```

IDW (optimal idp = 2)

```{r IDW}
Pred_IDW <- idw(Rn ~ 1 , InRn_DL, SPDF,
                nmax = 100,
                maxdist = 40, # km; Unprojected data: great-circle distance; For projected data Euclidian distances are computed 
                nmin = 5,
                idp = 2)
SPDF$IDW_Pred <- Pred_IDW$var1.pred
```

Plot map (grids cells of 0.015 x 0.015 degrees)
```{r IDW-plot}
InRn_Pred$IDW_Pred <- Pred_IDW$var1.pred
# Breaks 
breaks <- c(0, 50, 100, 200, 300, 500, max(InRn_Pred$IDW_Pred, na.rm = T))
InRn_Pred <- InRn_Pred %>% mutate(IDW_brks = cut(IDW_Pred, breaks, include.lowest = T, right = F))
# Plot predictions
cols <- colorRampPalette(c("blue", "red"))(6)
P_IDW_Pred <- ggplot() +
  geom_sf(data = Country) +
  geom_sf(data = InRn_Pred, aes(fill = IDW_brks, color = IDW_brks)) + 
  scale_fill_manual(name = "Bq/m3", values = cols, guide = guide_legend(reverse = TRUE)) +
  scale_color_manual(name = "Bq/m3", values = cols, guide = guide_legend(reverse = TRUE)) +
  geom_sf(data = InRn_DL, cex = 0.5) +
  ggtitle("IDW - Predictions") 
P_IDW_Pred
```

## Ordinary Kriging 
```{r OK}
### Variogram (gstat) ----
vg <- variogram(LogRn ~ 1, InRn_DL)   # great-circle distances (km)
vg_fit_Sph <- fit.variogram(vg, model = vgm("Sph"))
vg_fit_Exp <- fit.variogram(vg, vgm("Exp"))
```


```{r OK-variog}
plot(gamma ~ dist, vg,
     ylim = c(0, 1.05*max(vg$gamma)),
     col = 1,
     ylab = "semivariance",
     xlab = 'distance',
     main = "Variogram")

lines(variogramLine(vg_fit_Sph, 100), col = 'red') 
lines(variogramLine(vg_fit_Exp, 100), col = 'blue')

```


```{r OK-vg-fit}

vg_fit <- vg_fit_Exp

```

Test: Random permutations (100 random variograms)
```{r OK-vg-random}
V_Env <- list()
nsim <- 100
for (i in 1:nsim) {
  RP <- InRn_DL
  RP$LogRn <- sample(InRn_DL$LogRn)
  g_RP <- gstat(formula = LogRn ~ 1, data = RP) 
  vg_RP <- variogram(g_RP, cressie = F)
  V_Env[[i]] <- vg_RP 
}

vg_fit_Table <- data.frame(Model = vg_fit$model,
                           psill = round(vg_fit$psill, 2),
                           range = round(vg_fit$range, 2),
                           kappa = round(vg_fit$kappa, 2)
)
vg_Line <- cbind(variogramLine(vg_fit, maxdist = max(vg$dist)), id = "Model")

ggplot(vg, aes(x = dist, y = gamma, colour = id)) +
  geom_line(data = bind_rows(V_Env, .id="df"), aes(x = dist, y = gamma, group = df), colour="grey") +
  geom_point() +
  geom_line(data = vg_Line, size = 0.8) +
  ylim(0,2.5) + 
  annotation_custom(tableGrob(vg_fit_Table,rows = NULL),
                    xmin = 20, xmax = 45, ymin = 0.1, ymax = 1) + 
  ggtitle("Variogram")
```

 Interpolation - TransGaussian kriging using Box-Cox transforms (gstat) ----
```{r OK-inter}
SPDF <- as_Spatial(SPDF)
InRn_DL <- as_Spatial(InRn_DL)
lambda <- 0
Pred_OK <- krigeTg(Rn ~ 1, InRn_DL, SPDF,
                   model = vg_fit,
                   lambda = lambda,
                   maxdist = 40,  # km (great-circle distances)
                   nmax = 100,
                   nmin = 5)   
SPDF$OK_Pred <- Pred_OK$var1TG.pred   
SPDF$OK_SD <- sqrt(Pred_OK$var1TG.var)
SPDF$OK_RSD <- sqrt(Pred_OK$var1TG.var)/Pred_OK$var1TG.pred
```

Plot predictions (grids cells of 0.025 x 0.025 degrees) 
```{r OK-pred}
InRn_Pred$OK_Pred <- Pred_OK$var1TG.pred   
InRn_Pred$OK_SD <- sqrt(Pred_OK$var1TG.var)
InRn_Pred$OK_RSD <- sqrt(Pred_OK$var1TG.var)/Pred_OK$var1TG.pred
# Back to sf format
InRn_DL <- as(InRn_DL, "sf")
SPDF <- as(SPDF, "sf")
```


```{r OK-plot}
# Breaks 
breaks <- c(0, 50, 100, 200, 300, 500, max(InRn_Pred$OK_Pred, na.rm = T))
InRn_Pred <- InRn_Pred %>% mutate(OK_brks = cut(OK_Pred, breaks, include.lowest = T, right = F))
# Plot predictions
cols <- colorRampPalette(c("blue", "red"))(6)
P_OK_Pred <- ggplot() +
  geom_sf(data = Country) +
  geom_sf(data = InRn_Pred, aes(fill = OK_brks, color = OK_brks)) + 
  scale_fill_manual(name = "Bq/m3", values = cols, guide = guide_legend(reverse = TRUE)) +
  scale_color_manual(name = "Bq/m3", values = cols, guide = guide_legend(reverse = TRUE)) +
  geom_sf(data = InRn_DL, cex = 0.5) +
  ggtitle("OK - Predictions")
P_OK_Pred
```

Summarize by grids cells of 10 km x 10 km
```{r sim-grids-10}
## Estimate the mean of the points in each grid cell of 10 km x 10 km ----
# (or municipalities, districts, ...)
ggplot() +
  geom_sf(data = Country) +
  geom_sf(data = Grids_10km)+
  geom_sf(data = SPDF, col = 2, cex = 0.7)

## Intersect predictions (points - SPDF) and Grid cells of 10km x 10km  ----
SPDF_Grids10km <-  st_intersection(SPDF, Grids_10km) 
summary(SPDF_Grids10km)
```

Summarize (by Id)
```{r sum-grid-10-plot}
SPDF_Grids10km_Sum <- SPDF_Grids10km %>% 
  group_by(Id) %>% 
  summarize(N = n(),
            IDW_AM = mean(IDW_Pred, na.rm = T),
            IDW_SD = sd(IDW_Pred, na.rm = T),
            OK_AM  = mean(OK_Pred, na.rm = T), 
            OK_SD  = sd(OK_Pred, na.rm = T))
```

Add values to Grid cells of 10 x 10 km (Grids_10km_Sum)
```{r}
Grids_10km_Sum <- left_join(Grids_10km_Sum %>% as.data.frame(),
                            SPDF_Grids10km_Sum %>% as.data.frame(),
                            by = "Id")
Grids_10km_Sum <- Grids_10km_Sum %>%
  st_sf(sf_column_name = "geometry.x")
summary(Grids_10km_Sum)
```

Plot maps

```{r plot-grids-10km}
# Breaks 
breaks_IDW <- c(0, 25, 50, 75, 100, 200, max(Grids_10km_Sum$IDW_AM, na.rm = T))
breaks_OK  <- c(0, 25, 50, 75, 100, 200, max(Grids_10km_Sum$OK_AM, na.rm = T))
Grids_10km_Sum <- Grids_10km_Sum %>% 
  mutate(IDW_brks = cut(IDW_AM, breaks_IDW, include.lowest = T, right = F),
         OK_brks  = cut(OK_AM , breaks_OK , include.lowest = T, right = F))
# Maps 
P_Grids10km_IDW <- ggplot() +
  geom_sf(data = Country) + 
  geom_sf(data = Grids_10km_Sum, aes(fill = IDW_brks)) + 
  scale_fill_manual(name = "Bq/m3", values = cols, guide = guide_legend(reverse = TRUE)) +
  ggtitle("IDW - Predictions")
P_Grids10km_OK <- ggplot() +
  geom_sf(data = Country) + 
  geom_sf(data = Grids_10km_Sum, aes(fill = OK_brks)) + 
  scale_fill_manual(name = "Bq/m3", values = cols, guide = guide_legend(reverse = TRUE)) +
  ggtitle("OK - Predictions")

# Plot maps
grid.arrange(P_Grids10km_AM, P_Grids10km_IDW, P_Grids10km_OK, nrow = 1, ncol = 3)

## Export results to shape file (.shp) for GIS: InRn_Pred and  Grids_10km_Sum
#st_write(InRn_Pred, "InRn_Pred.shp", delete_layer = TRUE)           # overwrites
#st_write(Grids_10km_Sum, "Grids_10km_Sum.shp", delete_layer = TRUE) # overwrites
      
```


<!--chapter:end:04-Interpolation.Rmd-->

# Dose map

```{r}
summary(Grids_10km_Sum$OK_AM)
summary(Grids_10km_Sum$OK_SD)
```


```{r}
## New dataframe with AM and SD ----
Dose <- Grids_10km_Sum %>% transmute(Id = Id,
                                     Rn_AM = OK_AM,
                                     Rn_SD = OK_SD,
)
```


```{r}
## Dose [mSv/y] = CRn [Bq/m3] * FE * FO * TY [h/y] * FD [mSv / Bq.h.m-3]
# Uncertainty MC simulations
nsim <- 100
MC_Sim <- matrix(NA, nrow = length(Dose$Rn_AM), ncol = nsim)
TY <- 8760
for (i in 1:nsim) {
  Rn <- truncnorm::rtruncnorm(length(Dose$Rn_AM), a = 0, b = Inf, mean = Dose$Rn_AM, sd = Dose$Rn_SD)  # truncated:  Rn > 0
  FE <- rlnorm(1, meanlog = log(0.4), sdlog = log(1.15))
  FO <- rnorm(1, 0.8, 0.03)
  FD <- rnorm(1, 9e-06, 1.5e-06)
  MC_Sim[,i] <- Rn * FE * FO * TY * FD 
} 
MC_Sim <- as.data.frame(MC_Sim)
MC_Sim$Id <- Dose$Id
MC_Sim$Dose_AM <- rowMeans(MC_Sim[,1:nsim])
MC_Sim$Dose_SD <- apply(MC_Sim[,1:nsim], 1, sd)
```


```{r}
## Add AM and SD of the MC simulations to the dose table ----
Dose <- left_join(Dose %>% as.data.frame(),
                  MC_Sim[c("Id","Dose_AM","Dose_SD")] %>% as.data.frame,
                  by = "Id")
Dose <- Dose %>% st_sf(sf_column_name = "geometry.x")
```


```{r}
## Dose map ----
summary(Dose)

P_Dose_AM <- ggplot() +
  geom_sf(data = Country) + 
  geom_sf(data = Dose, aes(fill = Dose_AM)) +
  scale_fill_gradient(name = "mSv/y", low = "blue", high = "red") + 
  ggtitle("Radiation dose - AM")
P_Dose_AM

P_Dose_SD <- ggplot() +
  geom_sf(data = Country) + 
  geom_sf(data = Dose, aes(fill = Dose_SD)) +
  scale_fill_gradient(name = "mSv/y", low = "blue", high = "red") + 
  ggtitle("Radiation dose - SD")
P_Dose_SD

grid.arrange(P_Dose_AM, P_Dose_SD, nrow = 1, ncol = 2)
  
```


<!--chapter:end:05-summary.Rmd-->

# Interactive maps

```{r}

library(leaflet)

## Name of municipalities
  Lithuania <- readRDS(url("https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_2_sf.rds"))
  p_popup <- paste("<strong> Municipality: </strong>", Lithuania$NAME_2)  
  leaflet() %>%
    addPolygons(data = Lithuania,
                stroke = TRUE,
                weight = 2,
                fillColor = "grey",
                fillOpacity = 0.5,
                popup = p_popup) %>%
    addTiles()
 
```


```{r}
## Plot the AM (of the OK predictions) by grid cells of 10 km x 10 km (Grids_10km_Sum)
  p_popup <- paste("<strong> Id: </strong>", Grids_10km_Sum$Id, "<br>",
                   "<strong> AM: </strong>", round(Grids_10km_Sum$OK_AM, 2), "Bq/m3")
  pal_fun <- colorQuantile("YlOrRd", NULL, n = 6)
  
  Grids_10km_Sum %>% 
    leaflet() %>%
    addTiles()  %>%
    addPolygons(# add/remove polygon borders 
                stroke = TRUE, col = "grey", weight = 2,     
                # set fill color with function from above and value
                fillColor = ~pal_fun(OK_AM),  
                # make it nicer
                fillOpacity = 0.8, smoothFactor = 0.5,       
                popup = p_popup)
 
```


```{r}
## Plot the OK predictions by grid cells of 0.01 x 0.01 degrees (InRn_Pred)
  p_popup <- paste("<strong> InRn: </strong>", round(InRn_Pred$OK_Pred), "Bq/m3")
  pal_fun <- colorBin("YlOrRd", InRn_Pred$OK_Pred, bins = c(0,50,100, 200, 300, 500, max(InRn_Pred$OK_Pred)))
  
 InRn_Pred %>% 
   leaflet() %>%
    addTiles()  %>%
    addPolygons(stroke = TRUE, col= "grey", weight = 0.1,     
                fillColor = ~pal_fun(OK_Pred),  
                fillOpacity = 0.8, smoothFactor = 0.5,
                popup = p_popup) %>%
    addLegend(pal = pal_fun,
              values = ~OK_Pred,
              opacity = 1,
              labFormat = labelFormat(prefix = "[", suffix = ")", between = ", ", digits = 0),
              title = "InRn [Bq/m3]")

```


<!--chapter:end:06-Interactive-maps.Rmd-->

`r if (knitr::is_html_output()) '
# References {-}
'`

<!--chapter:end:07-references.Rmd-->

