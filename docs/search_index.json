[["index.html", "Geoinformatics with R Aplications for radon mapping Prerequisites R session", " Geoinformatics with R Aplications for radon mapping Javier El√≠o 2021-04-14 Prerequisites The data have been analysed with R (version 4.0.4) and Rstudio (versio 1.4.1106), and the book has been created with bookdown package. The required packages are automatically checked and installed if needed from CRAN. # Create an auxiliary function for checking if a package is installed, # install it if it is not, and load the package # (based on https://gist.github.com/stevenworthington/3178163) ipak &lt;- function(pkg){ new_pkg &lt;- pkg[!(pkg %in% installed.packages()[, &quot;Package&quot;])] if (length(new_pkg)) install.packages(new_pkg, dependencies = TRUE, repos = &quot;http://cran.us.r-project.org&quot;) sapply(pkg, require, character.only = TRUE) } # List of packages pkg &lt;- c(&quot;tidyverse&quot;, &quot;sf&quot;, &quot;sp&quot;, &quot;gstat&quot; ) # Check and install ipak(pkg) # You may also need to install the following packages #install.packages(c(&quot;MASS&quot;, &quot;StatDA&quot;, &quot;NADA&quot;, &quot;truncnorm&quot;, &quot;units&quot;, &quot;leaflet&quot;, &quot;ggspatial&quot;, &quot;gridExtra&quot;, &quot;rgdal&quot;)) R session # R version 4.0.4 (2021-02-15) # Platform: x86_64-w64-mingw32/x64 (64-bit) # Running under: Windows 10 x64 (build 17763) # # Matrix products: default # # locale: # [1] LC_COLLATE=English_United Kingdom.1252 LC_CTYPE=English_United Kingdom.1252 # [3] LC_MONETARY=English_United Kingdom.1252 LC_NUMERIC=C # [5] LC_TIME=English_United Kingdom.1252 # # attached base packages: # [1] stats graphics grDevices utils datasets methods base # # other attached packages: # [1] gstat_2.0-7 sp_1.4-5 sf_0.9-8 forcats_0.5.1 stringr_1.4.0 dplyr_1.0.5 # [7] purrr_0.3.4 readr_1.4.0 tidyr_1.1.3 tibble_3.1.0 ggplot2_3.3.3 tidyverse_1.3.0 # # loaded via a namespace (and not attached): # [1] leafem_0.1.3 colorspace_2.0-0 ellipsis_0.3.1 class_7.3-18 # [5] leaflet_2.0.4.1 satellite_1.0.2 base64enc_0.1-3 fs_1.5.0 # [9] rstudioapi_0.13 proxy_0.4-25 fansi_0.4.2 lubridate_1.7.9.2 # [13] xml2_1.3.2 codetools_0.2-18 splines_4.0.4 robustbase_0.93-7 # [17] knitr_1.31 jsonlite_1.7.2 broom_0.7.5 cluster_2.1.0 # [21] dbplyr_2.1.0 png_0.1-7 shiny_1.6.0 StatDA_1.7.4 # [25] compiler_4.0.4 httr_1.4.2 backports_1.2.1 mapview_2.9.0 # [29] assertthat_0.2.1 Matrix_1.3-2 fastmap_1.1.0 cli_2.3.1 # [33] later_1.1.0.1 htmltools_0.5.1.1 tools_4.0.4 gtable_0.3.0 # [37] glue_1.4.2 Rcpp_1.0.6 cellranger_1.1.0 jquerylib_0.1.3 # [41] raster_3.4-5 vctrs_0.3.6 sgeostat_1.0-27 nlme_3.1-152 # [45] crosstalk_1.1.1 xfun_0.22 rvest_1.0.0 mime_0.10 # [49] miniUI_0.1.1.1 lifecycle_1.0.0 DEoptimR_1.0-8 zoo_1.8-9 # [53] MASS_7.3-53 scales_1.1.1 hms_1.0.0 promises_1.2.0.1 # [57] yaml_2.2.1 MBA_0.0-9 NADA_1.6-1.1 sass_0.3.1 # [61] stringi_1.5.3 e1071_1.7-6 RandomFieldsUtils_0.5.3 manipulateWidget_0.10.1 # [65] intervals_0.15.2 rlang_0.4.10 pkgconfig_2.0.3 rgl_0.105.22 # [69] evaluate_0.14 lattice_0.20-41 htmlwidgets_1.5.3 tidyselect_1.1.0 # [73] magrittr_2.0.1 bookdown_0.21 R6_2.5.0 generics_0.1.0 # [77] DBI_1.1.1 pillar_1.5.1 haven_2.3.1 withr_2.4.1 # [81] mgcv_1.8-34 xts_0.12.1 units_0.7-1 survival_3.2-10 # [85] spacetime_1.2-4 modelr_0.1.8 crayon_1.4.1 KernSmooth_2.23-18 # [89] utf8_1.2.1 rmarkdown_2.7 geoR_1.8-1 RandomFields_3.3.8 # [93] grid_4.0.4 readxl_1.3.1 FNN_1.1.3 splancs_2.01-40 # [97] reprex_1.0.0 digest_0.6.27 classInt_0.4-3 webshot_0.5.2 # [101] xtable_1.8-4 httpuv_1.5.5 stats4_4.0.4 munsell_0.5.0 # [105] bslib_0.2.4 tcltk_4.0.4 "],["radon.html", "Chapter 1 Radon", " Chapter 1 Radon Introduction to radon and its adverse health effects. Radon and geology. Radon mapping, etc. "],["r-for-spatial-data-analisys.html", "Chapter 2 R for spatial data analisys", " Chapter 2 R for spatial data analisys R sf maps (ggplot2),  "],["indoor-radon.html", "Chapter 3 Indoor radon 3.1 Administrative divisions 3.2 Grids 10 x 10 km 3.3 Make our own grid (e.g. 0.1 x 0.1 degrees) 3.4 Geology 1:5M 3.5 Study area 3.6 Simulate indoor radon data", " Chapter 3 Indoor radon Create a simulated dataset of indoor radon concentration with 3/4 geogenic factors (e.g. bedrock geology, aquifers - karst/No-karst, uranium in topsoil) and as spatial autocorrelation of the residuals,  3.1 Administrative divisions I got Lithuania from www.gadm.org, but you may download the administrative areas of other countries Country &lt;- readRDS(url(&quot;https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_0_sf.rds&quot;)) County &lt;- readRDS(url(&quot;https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_1_sf.rds&quot;)) Muni &lt;- readRDS(url(&quot;https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_2_sf.rds&quot;)) 3.2 Grids 10 x 10 km Download from https://www.eea.europa.eu/data-and-maps/data/eea-reference-grids-2 EEA_Ref_grid_URL &lt;- &quot;https://www.eea.europa.eu/data-and-maps/data/eea-reference-grids-2/gis-files/lithuania-shapefile/at_download/file.zip&quot; temp &lt;- tempfile() temp2 &lt;- tempfile() download.file(EEA_Ref_grid_URL, temp) unzip(zipfile = temp, exdir = temp2) Grids_10km &lt;- read_sf(file.path(temp2, &quot;lt_10km.shp&quot;)) unlink(c(temp, temp2)) Grids_10km$Id &lt;- seq(1, length(Grids_10km$CELLCODE), 1) # Add new column with &quot;Id&quot; Grids_10km$Id &lt;- as.factor(Grids_10km$Id) # Stored as a vector of integer values st_crs(Grids_10km) # Coordinate Reference System # Coordinate Reference System: # User input: ETRS89 / ETRS-LAEA # wkt: # PROJCRS[&quot;ETRS89 / ETRS-LAEA&quot;, # BASEGEOGCRS[&quot;ETRS89&quot;, # DATUM[&quot;European Terrestrial Reference System 1989&quot;, # ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, # LENGTHUNIT[&quot;metre&quot;,1]]], # PRIMEM[&quot;Greenwich&quot;,0, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # ID[&quot;EPSG&quot;,4258]], # CONVERSION[&quot;unnamed&quot;, # METHOD[&quot;Lambert Azimuthal Equal Area&quot;, # ID[&quot;EPSG&quot;,9820]], # PARAMETER[&quot;Latitude of natural origin&quot;,52, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], # ID[&quot;EPSG&quot;,8801]], # PARAMETER[&quot;Longitude of natural origin&quot;,10, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], # ID[&quot;EPSG&quot;,8802]], # PARAMETER[&quot;False easting&quot;,4321000, # LENGTHUNIT[&quot;metre&quot;,1], # ID[&quot;EPSG&quot;,8806]], # PARAMETER[&quot;False northing&quot;,3210000, # LENGTHUNIT[&quot;metre&quot;,1], # ID[&quot;EPSG&quot;,8807]]], # CS[Cartesian,2], # AXIS[&quot;x&quot;,east, # ORDER[1], # LENGTHUNIT[&quot;metre&quot;,1]], # AXIS[&quot;y&quot;,north, # ORDER[2], # LENGTHUNIT[&quot;metre&quot;,1]], # ID[&quot;EPSG&quot;,3035]] st_crs(Country) # Coordinate Reference System # Coordinate Reference System: # User input: EPSG:4326 # wkt: # GEOGCRS[&quot;WGS 84&quot;, # DATUM[&quot;World Geodetic System 1984&quot;, # ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, # LENGTHUNIT[&quot;metre&quot;,1]]], # PRIMEM[&quot;Greenwich&quot;,0, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # CS[ellipsoidal,2], # AXIS[&quot;geodetic latitude (Lat)&quot;,north, # ORDER[1], # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # AXIS[&quot;geodetic longitude (Lon)&quot;,east, # ORDER[2], # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # USAGE[ # SCOPE[&quot;Horizontal component of 3D system.&quot;], # AREA[&quot;World.&quot;], # BBOX[-90,-180,90,180]], # ID[&quot;EPSG&quot;,4326]] Grids_10km &lt;- Grids_10km %&gt;% st_transform(4326) # Trandform coordinate system (from EPSG: 3035 to EPSG: 4326) st_crs(Grids_10km) # Coordinate Reference System # Coordinate Reference System: # User input: EPSG:4326 # wkt: # GEOGCRS[&quot;WGS 84&quot;, # DATUM[&quot;World Geodetic System 1984&quot;, # ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, # LENGTHUNIT[&quot;metre&quot;,1]]], # PRIMEM[&quot;Greenwich&quot;,0, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # CS[ellipsoidal,2], # AXIS[&quot;geodetic latitude (Lat)&quot;,north, # ORDER[1], # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # AXIS[&quot;geodetic longitude (Lon)&quot;,east, # ORDER[2], # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # USAGE[ # SCOPE[&quot;Horizontal component of 3D system.&quot;], # AREA[&quot;World.&quot;], # BBOX[-90,-180,90,180]], # ID[&quot;EPSG&quot;,4326]] st_crs(Country) # Coordinate Reference System # Coordinate Reference System: # User input: EPSG:4326 # wkt: # GEOGCRS[&quot;WGS 84&quot;, # DATUM[&quot;World Geodetic System 1984&quot;, # ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, # LENGTHUNIT[&quot;metre&quot;,1]]], # PRIMEM[&quot;Greenwich&quot;,0, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # CS[ellipsoidal,2], # AXIS[&quot;geodetic latitude (Lat)&quot;,north, # ORDER[1], # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # AXIS[&quot;geodetic longitude (Lon)&quot;,east, # ORDER[2], # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # USAGE[ # SCOPE[&quot;Horizontal component of 3D system.&quot;], # AREA[&quot;World.&quot;], # BBOX[-90,-180,90,180]], # ID[&quot;EPSG&quot;,4326]] Grids_10km &lt;- st_intersection(Grids_10km, Country) # Grids in the country plot(Grids_10km[&quot;Id&quot;]) 3.3 Make our own grid (e.g. 0.1 x 0.1 degrees) # Make regular grids (0.1 x 0.1) Grids &lt;- Country %&gt;% st_make_grid(cellsize = 0.1, what = &quot;polygons&quot;) %&gt;% st_sf() %&gt;% st_intersection(Country) %&gt;% # Name grids as &quot;g001&quot;, &quot;g002&quot; mutate(ID = paste0(&quot;g&quot;, stringr::str_pad(seq(1, nrow(.), 1), 3, pad = &quot;0&quot;))) # Centroid of the grid SPDF &lt;- st_centroid(Grids) plot(Country[&quot;NAME_0&quot;], reset = F, main = &quot;Lithuania: cells 0.1x0.1 degrees&quot;) plot(Grids, add = T, border = 2) plot(SPDF, add = T, col = &quot;blue&quot;) 3.4 Geology 1:5M Download from BGR (Asch 2003) IGME5000_url &lt;- &quot;https://download.bgr.de/bgr/Geologie/IGME5000/shp/IGME5000.zip&quot; temp &lt;- tempfile() temp2 &lt;- tempfile() download.file(IGME5000_url, temp) unzip(zipfile = temp, exdir = temp2) IGME5000 &lt;- read_sf(file.path(temp2, &quot;europe/data/IGME5000_europeEPSG3034shp_geology_poly_v01.shp&quot;)) unlink(c(temp, temp2)) st_crs(IGME5000) # Coordinate Reference System: # User input: ETRS89-extended / LCC Europe # wkt: # PROJCRS[&quot;ETRS89-extended / LCC Europe&quot;, # BASEGEOGCRS[&quot;ETRS89&quot;, # DATUM[&quot;European Terrestrial Reference System 1989&quot;, # ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, # LENGTHUNIT[&quot;metre&quot;,1]]], # PRIMEM[&quot;Greenwich&quot;,0, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # ID[&quot;EPSG&quot;,4258]], # CONVERSION[&quot;Europe Conformal 2001&quot;, # METHOD[&quot;Lambert Conic Conformal (2SP)&quot;, # ID[&quot;EPSG&quot;,9802]], # PARAMETER[&quot;Latitude of false origin&quot;,52, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], # ID[&quot;EPSG&quot;,8821]], # PARAMETER[&quot;Longitude of false origin&quot;,10, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], # ID[&quot;EPSG&quot;,8822]], # PARAMETER[&quot;Latitude of 1st standard parallel&quot;,35, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], # ID[&quot;EPSG&quot;,8823]], # PARAMETER[&quot;Latitude of 2nd standard parallel&quot;,65, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], # ID[&quot;EPSG&quot;,8824]], # PARAMETER[&quot;Easting at false origin&quot;,4000000, # LENGTHUNIT[&quot;metre&quot;,1], # ID[&quot;EPSG&quot;,8826]], # PARAMETER[&quot;Northing at false origin&quot;,2800000, # LENGTHUNIT[&quot;metre&quot;,1], # ID[&quot;EPSG&quot;,8827]]], # CS[Cartesian,2], # AXIS[&quot;northing (N)&quot;,north, # ORDER[1], # LENGTHUNIT[&quot;metre&quot;,1]], # AXIS[&quot;easting (E)&quot;,east, # ORDER[2], # LENGTHUNIT[&quot;metre&quot;,1]], # USAGE[ # SCOPE[&quot;Conformal mapping at scales of 1:500,000 and smaller.&quot;], # AREA[&quot;Europe - European Union (EU) countries and candidates. Europe - onshore and offshore: Albania; Andorra; Austria; Belgium; Bosnia and Herzegovina; Bulgaria; Croatia; Cyprus; Czechia; Denmark; Estonia; Faroe Islands; Finland; France; Germany; Gibraltar; Greece; Hungary; Iceland; Ireland; Italy; Kosovo; Latvia; Liechtenstein; Lithuania; Luxembourg; Malta; Monaco; Montenegro; Netherlands; North Macedonia; Norway including Svalbard and Jan Mayen; Poland; Portugal including Madeira and Azores; Romania; San Marino; Serbia; Slovakia; Slovenia; Spain including Canary Islands; Sweden; Switzerland; Turkey; United Kingdom (UK) including Channel Islands and Isle of Man; Vatican City State.&quot;], # BBOX[24.6,-35.58,84.17,44.83]], # ID[&quot;EPSG&quot;,3034]] st_crs(Country) # Coordinate Reference System: # User input: EPSG:4326 # wkt: # GEOGCRS[&quot;WGS 84&quot;, # DATUM[&quot;World Geodetic System 1984&quot;, # ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, # LENGTHUNIT[&quot;metre&quot;,1]]], # PRIMEM[&quot;Greenwich&quot;,0, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # CS[ellipsoidal,2], # AXIS[&quot;geodetic latitude (Lat)&quot;,north, # ORDER[1], # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # AXIS[&quot;geodetic longitude (Lon)&quot;,east, # ORDER[2], # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # USAGE[ # SCOPE[&quot;Horizontal component of 3D system.&quot;], # AREA[&quot;World.&quot;], # BBOX[-90,-180,90,180]], # ID[&quot;EPSG&quot;,4326]] IGME5000 &lt;- IGME5000 %&gt;% st_transform(4326) %&gt;% st_intersection(Country) st_crs(IGME5000) # Coordinate Reference System: # User input: EPSG:4326 # wkt: # GEOGCRS[&quot;WGS 84&quot;, # DATUM[&quot;World Geodetic System 1984&quot;, # ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, # LENGTHUNIT[&quot;metre&quot;,1]]], # PRIMEM[&quot;Greenwich&quot;,0, # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # CS[ellipsoidal,2], # AXIS[&quot;geodetic latitude (Lat)&quot;,north, # ORDER[1], # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # AXIS[&quot;geodetic longitude (Lon)&quot;,east, # ORDER[2], # ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], # USAGE[ # SCOPE[&quot;Horizontal component of 3D system.&quot;], # AREA[&quot;World.&quot;], # BBOX[-90,-180,90,180]], # ID[&quot;EPSG&quot;,4326]] plot(IGME5000[&quot;AgeName&quot;]) 3.5 Study area I will focus the data analysis in a region of of 1x1 degrees # First: build a rectangle Area &lt;- matrix(NA, ncol = 2, nrow = 4) Area &lt;- as.data.frame(Area) names(Area) &lt;- c(&quot;X&quot;,&quot;Y&quot;) Area[1,] &lt;- c(23,55) Area[2,] &lt;- c(23,56) Area[3,] &lt;- c(24,56) Area[4,] &lt;- c(24,55) coordinates(Area) &lt;- ~X+Y Area &lt;- rbind(Area,Area[1,]) Area &lt;- Polygons(list(Polygon(Area)),ID=&quot;Area&quot;) Area &lt;- SpatialPolygons(list(Area)) Area &lt;- as(Area, &quot;sf&quot;) st_crs(Area) &lt;- st_crs(Country) plot(Country[&quot;NAME_0&quot;], axes = TRUE, reset = F) plot(Area, col = &quot;blue&quot;, add = T) # Second: intersect Area with all the data Country &lt;- st_intersection(Country, Area) County &lt;- st_intersection(County, Area) Muni &lt;- st_intersection(Muni, Area) Grids_10km &lt;- st_intersection(Grids_10km, Area) IGME5000 &lt;- st_intersection(IGME5000, Area) 3.6 Simulate indoor radon data Please be aware that I am using SIMULATED data, and therefore data interpretation is NOT real. Any coincidence with a real case (i.e. Lithuania) is casual. Data are only useful for training purpose, you may need to read your own data for data interpretation. set.seed(1) # Make the simulation reproducible # Radom points in the study area N &lt;- 1000 X &lt;- runif(N,23.0001,23.9999) Y &lt;- runif(N,55.0001,55.9999) points &lt;- cbind(X,Y) points &lt;- as.data.frame(points) coordinates(points) &lt;- ~X+Y proj4string(points) &lt;- CRS(&quot;EPSG:4326&quot;) points &lt;- as(points, &quot;sf&quot;) points &lt;- st_intersection(points, Country) points &lt;- as_Spatial(points) # define the gstat object (spatial model) library(gstat) g_dummy &lt;- gstat(formula = z ~ 1, locations = ~ X + Y, dummy = T, beta = 3, model = vgm(psill = 1.5, model = &quot;Exp&quot;, range = 10, nugget = 0.5), nmax = 100) # Simulations based on the gstat object points &lt;- predict(g_dummy, newdata = points, nsim = 1) # [using unconditional Gaussian simulation] points$Rn &lt;- exp(points$sim1) # Final result: Simulated indoor radon dataset (InRn) in Bq m-3 InRn &lt;- points[,&quot;Rn&quot;] # Detection Limit (DL): 10 Bq m-3 (replaced by half of the Limit of Detection) InRn[InRn$Rn &lt;= 10,] &lt;- 5 InRn &lt;- as(InRn, &quot;sf&quot;) %&gt;% st_transform(crs = &quot;EPSG:4326&quot;) "],["exploratory-data-analysis.html", "Chapter 4 Exploratory data analysis 4.1 Histogram 4.2 Missing data 4.3 Spatial distribution", " Chapter 4 Exploratory data analysis 4.1 Histogram Rn hist(InRn$Rn, prob = T, col = &quot;red&quot;, breaks = 10, main = &quot;Histogram Indoor Radon&quot;, xlab = expression(&quot;Rn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) StatDA::qqplot.das(InRn$Rn, distribution = &quot;norm&quot;, col = 1, envelope = 0.95, datax = T, main = &quot;Q-Q plot (InRn)&quot;) ## Box-Cox transformation ---- BCT &lt;- MASS::boxcox(InRn$Rn ~ 1, lambda = seq(-1, 1, 1/100)) title(&quot;Box-Cox Transformation&quot;) BCT &lt;- as.data.frame(BCT) # lambda &lt;- BCT[BCT$y == max(BCT$y), ]$x # -0.17 # InRn$BCT &lt;- (InRn$Rn^lambda-1)/lambda lambda &lt;- 0 InRn$LogRn &lt;- log(InRn$Rn) ## Histogram (logRn) ---- hist(InRn$LogRn, col = &quot;red&quot;, breaks = 30, prob = T, main = &quot;Histogram Indoor Radon&quot;, xlab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) StatDA::qqplot.das(InRn$LogRn, distribution = &quot;norm&quot;, col = 1, envelope = 0.95,datax=T, main = &quot;Q-Q plot (log InRn)&quot;) 4.2 Missing data Imputation of values below the detection limit ## ROS: ROBUST IMPUTATION METHOD ---- DL &lt;- 10 InRn_DL &lt;- InRn InRn_DL$Rn_Cen &lt;- &quot;FALSE&quot; InRn_DL[InRn_DL$Rn &lt;= DL,][&quot;Rn_Cen&quot;] &lt;- &quot;TRUE&quot; InRn_DL$Rn_Cen &lt;- as.logical(InRn_DL$Rn_Cen) ROS &lt;- NADA::ros(InRn_DL$Rn, InRn_DL$Rn_Cen, forwardT = &quot;log&quot;) ROS &lt;- as.data.frame(ROS) # Replace Dl by the modeled values InRn_DL[InRn_DL$Rn_Cen == &quot;TRUE&quot;,][&quot;Rn&quot;] &lt;- ROS[ROS$censored == &quot;TRUE&quot;,][&quot;modeled&quot;] InRn_DL$LogRn &lt;- log(InRn_DL$Rn) ## q-q plots ---- par(mfrow=c(1,2)) StatDA::qqplot.das(InRn$LogRn, distribution = &quot;norm&quot;, col = 1, envelope = 0.95, datax = T, main = &quot;Original data&quot;) StatDA::qqplot.das(InRn_DL$LogRn, distribution = &quot;norm&quot;, col = 1, envelope = 0.95, datax = T, main = &quot;After ROS&quot;) mean(InRn$Rn) # [1] 64.1 sd(InRn$Rn) # [1] 126 exp(mean(InRn$LogRn)) # [1] 25.7 exp(sd(InRn$LogRn)) # [1] 3.68 RL &lt;- 200 # Bq m-3 100*(1 - pnorm(log(RL), mean = mean(InRn$LogRn), sd = sd(InRn$LogRn))) # [1] 5.8 mean(InRn_DL$Rn) # [1] 64.1 sd(InRn_DL$Rn) # [1] 126 exp(mean(InRn_DL$LogRn)) # [1] 24.8 exp(sd(InRn_DL$LogRn)) # [1] 4.04 100*(1-pnorm(log(RL), mean = mean(InRn_DL$LogRn), sd = sd(InRn_DL$LogRn))) # [1] 6.74 ## Histogram (logRn) ---- par(mfrow=c(1,2)) hist(InRn$LogRn, col = &quot;red&quot;, breaks = 30, prob = T, ylim = c(0, 0.5), main = &quot;Origical data&quot;, xlab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) hist(InRn_DL$LogRn, col = &quot;red&quot;, breaks = 30, prob = T, ylim = c(0, 0.5), main = &quot;After ROS&quot;, xlab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) ## Histogram, boxplot, q-q plot ---- par(mfrow = c(1,3)) hist(InRn_DL$LogRn, col = &quot;red&quot;, breaks = 30, prob = T, main = &quot;Histogram&quot;, xlab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) lines(density(InRn_DL$LogRn), lwd = 1) boxplot(InRn_DL$LogRn, notch = TRUE, col=2, varwidth = TRUE, main = &quot;Boxplot&quot;, ylab = &quot;Lognormal transformation&quot;, xlab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) StatDA::qqplot.das(InRn_DL$LogRn, distribution = &quot;norm&quot;, col = 1, envelope = 0.95, datax = T, ylab = &quot;Observed Value&quot;, xlab = &quot;Expected Normal Value&quot;, main = (&quot;Normal Q-Q plot&quot;), line = &quot;quartiles&quot;, pch = 3, cex = 0.7, xaxt = &quot;s&quot;) 4.3 Spatial distribution ## Plot InRn measurements in Bq/m3 (with ggplot2) ---- P_Rn &lt;- ggplot() + geom_sf(data = Grids_10km) + geom_sf(data = InRn_DL, aes(color = Rn)) + scale_color_gradient(name = &quot;Bq/m3&quot;, low = &quot;blue&quot;, high = &quot;red&quot;) + ggtitle(&quot;Indoor radon measurements (Simulated)&quot;) P_Rn ## Change intervale in the Rn scale ---- breaks &lt;- c(0, 50, 100, 200, 300, 500, max(InRn_DL$Rn)) InRn_DL &lt;- InRn_DL %&gt;% mutate(brks = cut(Rn, breaks, include.lowest = T, right = F)) cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) # cols &lt;- terrain.colors(6) # cols &lt;- heat.colors(6, alpha = 1) # cols &lt;- colorRampPalette(c(&quot;yellow&quot;, &quot;red&quot;))(6) P_Rn_brks &lt;- ggplot() + geom_sf(data = Grids_10km) + geom_sf(data = InRn_DL, aes(fill = brks, color = brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + scale_color_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + ggtitle(&quot;Indoor radon measurements (Simulated)&quot;) P_Rn_brks ## Plot if Rn is higher than Reference level (1) or not (0) ---- # Transform InRn to: 1 if Rn &gt;= RL or 0 if Rn &lt; RL (&quot;Case&quot;) RL &lt;- 200 # Bq m-3 InRn_DL &lt;- InRn_DL %&gt;% mutate(Case = as.factor(ifelse(Rn &gt;= 200, yes = 1, no = 0))) P_Cases &lt;- ggplot() + geom_sf(data = Grids_10km) + geom_sf(data = InRn_DL, aes(fill = Case, color = Case)) + scale_fill_manual( name = &quot;Bq/m3&quot;, labels = c(&quot;&lt; 200&quot;,&quot;&gt;= 200&quot;), values = c(&quot;lightgreen&quot;, &quot;red&quot;)) + scale_color_manual(name = &quot;Bq/m3&quot;, labels = c(&quot;&lt; 200&quot;,&quot;&gt;= 200&quot;), values = c(&quot;lightgreen&quot;, &quot;red&quot;)) + # theme(legend.position = &quot;none&quot;) + ggtitle(&quot;Indoor radon measurements (Simulated)&quot;) P_Cases ## Kernel density plots ---- # The resulting density map is noisier for small bandwidth (h) # and smoother for large bandwidth (h). # A rule-of-thumb for an optimal value is h  max(sx, sy)*0.7*n^-0.2 # where n is the number of points, # and sx and sy the standard deviations of x- and y- coordinates of the points # See printed version of the EU Atlas for further information (in progress) # 2.4. Statistics, measurements, maping (part wirtten by P. Bossew) # All dwelling sampled (e.g. for detecting possible clusters; avoid overplotting) H &lt;- st_coordinates(InRn_DL) h &lt;- max(sd(H[,&quot;X&quot;]), sd(H[,&quot;Y&quot;])) * 0.7 * nrow(H)^-0.2 KP_all &lt;- InRn_DL %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% ggplot() + geom_sf(data = Grids_10km) + stat_density_2d(aes(X, Y, fill = ..level.., alpha = ..level..), h = h, geom = &quot;polygon&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme(legend.position = &quot;none&quot;) + #geom_sf(data = InRn_DL, size = .1) + ggtitle(&quot;Kernel density plots (all data)&quot;) + labs(x = &quot;&quot;, y = &quot;&quot;) KP_all # Only dwellings with InRn &gt; RL (cases == 1) H &lt;- st_coordinates(filter(InRn_DL, Case == 1)) h &lt;- max(sd(H[,&quot;X&quot;]), sd(H[,&quot;Y&quot;])) * 0.7 * nrow(H)^-0.2 KP_Cases &lt;- InRn_DL %&gt;% filter(Case == 1) %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% ggplot() + geom_sf(data = Grids_10km) + stat_density_2d(aes(X, Y, fill = ..level.., alpha = ..level..), h = h, geom = &quot;polygon&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme(legend.position = &quot;none&quot;) + geom_sf(data = filter(InRn_DL, Case == 1), size = .1) + ggtitle(&quot;Kernel density plots (InRn &gt;= 200 Bq/m3)&quot;) + labs(x = &quot;&quot;, y = &quot;&quot;) KP_Cases # Only dwellings with InRn &lt; RL (cases) H &lt;- st_coordinates(filter(InRn_DL, Case == 0)) h &lt;- max(sd(H[,&quot;X&quot;]), sd(H[,&quot;Y&quot;])) * 0.7 * nrow(H)^-0.2 KP_No_Cases &lt;- InRn_DL %&gt;% filter(Case == 0) %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% ggplot() + geom_sf(data = Grids_10km) + stat_density_2d(aes(X, Y, fill = ..level.., alpha = ..level..), h = h, geom = &quot;polygon&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme(legend.position = &quot;none&quot;) + geom_sf(data = filter(InRn_DL, Case == 0), size = .1) + ggtitle(&quot;Kernel density plots (InRn &lt; 200 Bq/m3)&quot;) + labs(x = &quot;&quot;, y = &quot;&quot;) KP_No_Cases # Plot two (or more) figures in one library(gridExtra) grid.arrange(KP_No_Cases, KP_Cases, nrow = 2) grid.arrange(KP_No_Cases, KP_Cases, nrow = 1) # InRn vs Geologia ---- P_BG &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = IGME5000, aes(fill = AgeName), colour = NA) + geom_sf(data = InRn_DL, aes(), colour = 1, cex = 0.8) + scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) + ggtitle(&quot;Geology 1:1M&quot;) P_BG ## Intersect ---- InRn_DL_BG &lt;- st_intersection(InRn_DL, IGME5000) ## Boxplots ---- par(mar = c(9,5,3,0.5), oma = c(0, 0.5, 0.5, 0.5), mfrow = c(1,1)) boxplot(LogRn ~ AgeName, InRn_DL_BG, col = 2, varwidth = TRUE, notch = T, las = 2, ylab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;), xlab = &quot;&quot;, main = &quot;Geology (AgeName)&quot;) # ANOVA ---- lm_BG &lt;- lm(LogRn ~ AgeName, InRn_DL_BG) summary(lm_BG) # # Call: # lm(formula = LogRn ~ AgeName, data = InRn_DL_BG) # # Residuals: # Min 1Q Median 3Q Max # -3.952 -0.904 -0.029 0.974 4.048 # # Coefficients: # Estimate Std. Error t value Pr(&gt;|t|) # (Intercept) 2.822 0.104 27.19 &lt;2e-16 *** # AgeNameEarly Triassic 0.255 0.136 1.87 0.0617 . # AgeNameLate Devonian 0.517 0.133 3.90 0.0001 *** # AgeNameLate Jurassic 0.859 0.137 6.28 5e-10 *** # AgeNameLate Permian -0.247 0.184 -1.34 0.1793 # AgeNameMiddle Jurassic 0.767 0.464 1.65 0.0986 . # --- # Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # # Residual standard error: 1.36 on 994 degrees of freedom # Multiple R-squared: 0.0613, Adjusted R-squared: 0.0566 # F-statistic: 13 on 5 and 994 DF, p-value: 2.89e-12 anova(lm_BG) # Analysis of Variance Table # # Response: LogRn # Df Sum Sq Mean Sq F value Pr(&gt;F) # AgeName 5 120 23.92 13 2.9e-12 *** # Residuals 994 1830 1.84 # --- # Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 "],["summary-statistics.html", "Chapter 5 Summary statistics", " Chapter 5 Summary statistics ## InRn by grids of 10 x 10 km (summry: N, AM, SD, GM, GSD) ---- InRn_DL &lt;- st_intersection(InRn_DL, Grids_10km) str(InRn_DL) # Classes &#39;sf&#39; and &#39;data.frame&#39;: 1000 obs. of 12 variables: # $ Rn : num 5.113 0.785 1.763 6.323 36.349 ... # $ LogRn : num 1.632 -0.242 0.567 1.844 3.593 ... # $ Rn_Cen : logi TRUE TRUE TRUE TRUE FALSE FALSE ... # $ brks : Factor w/ 6 levels &quot;[0,50)&quot;,&quot;[50,100)&quot;,..: 1 1 1 1 1 4 1 3 2 1 ... # $ Case : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 1 1 1 2 1 1 1 1 ... # $ CELLCODE : chr &quot;10kmE512N372&quot; &quot;10kmE513N367&quot; &quot;10kmE513N367&quot; &quot;10kmE513N367&quot; ... # $ EOFORIGIN: num 5120000 5130000 5130000 5130000 5130000 5130000 5130000 5130000 5130000 5130000 ... # $ NOFORIGIN: num 3720000 3670000 3670000 3670000 3680000 3680000 3680000 3680000 3680000 3690000 ... # $ Id : Factor w/ 1022 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 341 362 362 362 363 363 363 363 363 364 ... # $ GID_0 : chr &quot;LTU&quot; &quot;LTU&quot; &quot;LTU&quot; &quot;LTU&quot; ... # $ NAME_0 : chr &quot;Lithuania&quot; &quot;Lithuania&quot; &quot;Lithuania&quot; &quot;Lithuania&quot; ... # $ geometry :sfc_POINT of length 1000; first list element: &#39;XY&#39; num 23 56 # - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; # - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA ... # ..- attr(*, &quot;names&quot;)= chr [1:11] &quot;Rn&quot; &quot;LogRn&quot; &quot;Rn_Cen&quot; &quot;brks&quot; ... InRn_DL$Case &lt;- as.numeric(as.character(InRn_DL$Case)) InRn_Summary_Grids10km &lt;- InRn_DL %&gt;% group_by(Id) %&gt;% summarize(N = n(), Case = sum(Case), AM = mean(Rn), SD = sd(Rn), GM = exp(mean((LogRn))), GSD = exp(sd(LogRn)), MIN = min(Rn), MAX = max(Rn)) ## Add summary to grids of 10x10 km ---- Grids_10km_Sum &lt;- left_join(Grids_10km %&gt;% as.data.frame(), InRn_Summary_Grids10km %&gt;% as.data.frame(), by = &quot;Id&quot;) Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% st_sf(sf_column_name = &quot;geometry.x&quot;) %&gt;% mutate(N = replace_na(N, 0)) summary(Grids_10km_Sum) # CELLCODE EOFORIGIN NOFORIGIN Id GID_0 NAME_0 # Length:93 Min. :5120000 Min. :3610000 340 : 1 Length:93 Length:93 # Class :character 1st Qu.:5150000 1st Qu.:3640000 341 : 1 Class :character Class :character # Mode :character Median :5160000 Median :3670000 361 : 1 Mode :character Mode :character # Mean :5163871 Mean :3674516 362 : 1 # 3rd Qu.:5180000 3rd Qu.:3710000 363 : 1 # Max. :5210000 Max. :3740000 364 : 1 # (Other):87 # N Case AM SD GM GSD MIN # Min. : 0.0 Min. :0.00 Min. : 3 Min. : 1 Min. : 2 Min. :1.12 Min. : 0.3 # 1st Qu.: 7.0 1st Qu.:0.00 1st Qu.: 19 1st Qu.: 19 1st Qu.: 11 1st Qu.:2.28 1st Qu.: 1.7 # Median :12.0 Median :0.00 Median : 39 Median : 39 Median : 24 Median :2.75 Median : 4.2 # Mean :10.8 Mean :0.77 Mean : 69 Mean : 68 Mean : 45 Mean :2.95 Mean : 11.4 # 3rd Qu.:14.0 3rd Qu.:1.00 3rd Qu.: 86 3rd Qu.: 77 3rd Qu.: 54 3rd Qu.:3.44 3rd Qu.: 11.3 # Max. :22.0 Max. :9.00 Max. :687 Max. :549 Max. :472 Max. :6.20 Max. :143.2 # NA&#39;s :7 NA&#39;s :7 NA&#39;s :11 NA&#39;s :7 NA&#39;s :11 NA&#39;s :7 # MAX geometry.x geometry.y # Min. : 5 POLYGON :93 GEOMETRYCOLLECTION: 7 # 1st Qu.: 59 epsg:4326 : 0 MULTIPOINT :82 # Median : 132 +proj=long...: 0 POINT : 4 # Mean : 213 epsg:4326 : 0 # 3rd Qu.: 230 +proj=long... : 0 # Max. :1615 # NA&#39;s :7 ## Plot number of data in each grid cell ---- cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) P_Grids10km_N &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km_Sum, aes(fill = N)) + scale_fill_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) + ggtitle(&quot;Number of data&quot;) P_Grids10km_N ## Plot arithmetic mean ---- max(Grids_10km_Sum$AM, na.rm = T) # [1] 687 breaks &lt;- c(0, 25, 50, 75, 100, 200, max(Grids_10km_Sum$AM, na.rm = T)) Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% mutate(AM_brks = cut(AM, breaks, include.lowest = T, right = F)) cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) P_Grids10km_AM &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km_Sum, aes(fill = AM_brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + ggtitle(&quot;Arithmetic mean&quot;) P_Grids10km_AM ## Probabilistic maps ---- # Probability of having an indoor radon concentration above the national reference level (e.g. RL = 200 Bq m-3) # Based solely on the indoor radon measurements in each grid of 10x10 km, # and assuming data independence and lognormality str(Grids_10km_Sum) # Classes &#39;sf&#39; and &#39;data.frame&#39;: 93 obs. of 17 variables: # $ CELLCODE : chr &quot;10kmE512N371&quot; &quot;10kmE512N372&quot; &quot;10kmE513N366&quot; &quot;10kmE513N367&quot; ... # $ EOFORIGIN : num 5120000 5120000 5130000 5130000 5130000 5130000 5130000 5130000 5130000 5130000 ... # $ NOFORIGIN : num 3710000 3720000 3660000 3670000 3680000 3690000 3700000 3710000 3720000 3730000 ... # $ Id : Factor w/ 1022 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 340 341 361 362 363 364 365 366 367 368 ... # $ GID_0 : chr &quot;LTU&quot; &quot;LTU&quot; &quot;LTU&quot; &quot;LTU&quot; ... # $ NAME_0 : chr &quot;Lithuania&quot; &quot;Lithuania&quot; &quot;Lithuania&quot; &quot;Lithuania&quot; ... # $ N : num 0 1 0 3 5 12 19 15 10 0 ... # $ Case : num NA 0 NA 0 1 0 0 0 0 NA ... # $ AM : num NA 5.11 NA 2.96 97.47 ... # $ SD : num NA NA NA 2.96 91.43 ... # $ GM : num NA 5.11 NA 2.06 56.42 ... # $ GSD : num NA NA NA 2.86 3.79 ... # $ MIN : num NA 5.113 NA 0.785 8.032 ... # $ MAX : num NA 5.11 NA 6.32 205.46 ... # $ geometry.x:sfc_POLYGON of length 93; first list element: List of 1 # ..$ : num [1:4, 1:2] 23 23 23 23 55.9 ... # ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;POLYGON&quot; &quot;sfg&quot; # $ geometry.y:sfc_GEOMETRY of length 93; first list element: list() # ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;GEOMETRYCOLLECTION&quot; &quot;sfg&quot; # $ AM_brks : Factor w/ 6 levels &quot;[0,25)&quot;,&quot;[25,50)&quot;,..: NA 1 NA 1 4 1 1 2 1 NA ... # - attr(*, &quot;sf_column&quot;)= chr &quot;geometry.x&quot; # - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA ... # ..- attr(*, &quot;names&quot;)= chr [1:15] &quot;CELLCODE&quot; &quot;EOFORIGIN&quot; &quot;NOFORIGIN&quot; &quot;Id&quot; ... # 1st: estimated Prob[InRn &gt; 200 Bq m-3] RL &lt;- 200 Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% mutate(Prob = 100*(1-pnorm(log(RL), mean = log(GM), sd = log(GSD)))) # 2nd: Replace values in grids with less than n data (i.e. N &lt; 5) by a modeled value # Generate the points for the interpolation (centroid) DCen &lt;- st_centroid(Grids_10km_Sum) # Inverse distance weighted (IDW) interpolation Prob_IDW &lt;- idw(Prob ~ 1, filter(DCen, N &gt; 5), newdata = filter(DCen, N &lt;= 5), nmax = 10, idp = 2 ) # [inverse distance weighted interpolation] # Replace values by the modeled values Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% mutate(Prob = replace(Prob, N &lt;= 5, Prob_IDW$var1.pred)) # Plot maps breaks &lt;- c(0, 1, 5, 10, 20, 30, max(Grids_10km_Sum$Prob)) Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% mutate(Prob_brks = cut(Prob, breaks, include.lowest = T, right = F)) cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) P_Grids10km_Prob &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km_Sum, aes(fill = Prob_brks)) + scale_fill_manual(name = &quot;%&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + ggtitle(&quot;Prob[InRn &gt; 200 Bq m-3]&quot;) P_Grids10km_Prob "],["geostatistics.html", "Chapter 6 Geostatistics 6.1 Inverse distance weighted interpolation (IDW) 6.2 Ordinary Kriging", " Chapter 6 Geostatistics Prediction by grids of 0.015 x 0.015 degrees InRn_Pred &lt;- st_make_grid(Country, cellsize = .015, what = &quot;polygons&quot;) InRn_Pred &lt;- st_sf(InRn_Pred) SPDF &lt;- st_centroid(InRn_Pred) # predict in the center of the grid plot(InRn_Pred, reset = F) plot(SPDF, add = T, col = 2, pch = 16, cex = 0.7) 6.1 Inverse distance weighted interpolation (IDW) ### Optimal idp (10 k-fold Croos Validation) ---- data &lt;- InRn_DL res &lt;- numeric() IDP_RMSE &lt;- numeric() idp &lt;- seq(1,4,0.25) k &lt;- 10 folds &lt;- sample(x = 1:k, size = length(data$Rn), replace = TRUE) CV &lt;- matrix(NA,length(idp),2) for (j in 1:length(idp)) { for (i in 1:k) { m_model &lt;- data[folds != i, ] m_valid &lt;- data[folds == i, ] m_valid_pred &lt;- idw(Rn ~ 1 , m_model, m_valid, nmax = 100, maxdist = 40, nmin = 5, idp = idp[j]) res &lt;- m_valid$Rn - m_valid_pred$var1.pred IDP_RMSE[i] &lt;- sqrt(mean(res^2)) } CV[j,1] &lt;- idp[j] CV[j,2] &lt;- sqrt(mean(IDP_RMSE^2)) } # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] # [inverse distance weighted interpolation] CV &lt;- as.data.frame(CV) names(CV) &lt;- c(&quot;idp&quot;,&quot;RSME&quot;) plot(RSME ~ idp, CV) lines(RSME ~ idp, CV, col = 2) axis(1, labels = F, at = seq(0,10,0.5)) abline(v = seq(0,4,0.25), lty = 2, lwd = 1.5, col=&quot;gray&quot;) abline(h = seq(100,200,2), lty = 2, lwd = 1.5, col = &quot;gray&quot;) title(&quot;10-fold cross-validation&quot;) IDW (optimal idp = 2) Pred_IDW &lt;- idw(Rn ~ 1 , InRn_DL, SPDF, nmax = 100, maxdist = 40, # km; Unprojected data: great-circle distance; For projected data Euclidian distances are computed nmin = 5, idp = 2) # [inverse distance weighted interpolation] SPDF$IDW_Pred &lt;- Pred_IDW$var1.pred Plot map (grids cells of 0.015 x 0.015 degrees) InRn_Pred$IDW_Pred &lt;- Pred_IDW$var1.pred # Breaks breaks &lt;- c(0, 50, 100, 200, 300, 500, max(InRn_Pred$IDW_Pred, na.rm = T)) InRn_Pred &lt;- InRn_Pred %&gt;% mutate(IDW_brks = cut(IDW_Pred, breaks, include.lowest = T, right = F)) # Plot predictions cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) P_IDW_Pred &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = InRn_Pred, aes(fill = IDW_brks, color = IDW_brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + scale_color_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + geom_sf(data = InRn_DL, cex = 0.5) + ggtitle(&quot;IDW - Predictions&quot;) P_IDW_Pred 6.2 Ordinary Kriging ### Variogram (gstat) ---- vg &lt;- variogram(LogRn ~ 1, InRn_DL) # great-circle distances (km) vg_fit_Sph &lt;- fit.variogram(vg, model = vgm(&quot;Sph&quot;)) vg_fit_Exp &lt;- fit.variogram(vg, vgm(&quot;Exp&quot;)) plot(gamma ~ dist, vg, ylim = c(0, 1.05*max(vg$gamma)), col = 1, ylab = &quot;semivariance&quot;, xlab = &#39;distance&#39;, main = &quot;Variogram&quot;) lines(variogramLine(vg_fit_Sph, 100), col = &#39;red&#39;) lines(variogramLine(vg_fit_Exp, 100), col = &#39;blue&#39;) vg_fit &lt;- vg_fit_Exp Test: Random permutations (100 random variograms) V_Env &lt;- list() nsim &lt;- 100 for (i in 1:nsim) { RP &lt;- InRn_DL RP$LogRn &lt;- sample(InRn_DL$LogRn) g_RP &lt;- gstat(formula = LogRn ~ 1, data = RP) vg_RP &lt;- variogram(g_RP, cressie = F) V_Env[[i]] &lt;- vg_RP } vg_fit_Table &lt;- data.frame(Model = vg_fit$model, psill = round(vg_fit$psill, 2), range = round(vg_fit$range, 2), kappa = round(vg_fit$kappa, 2) ) vg_Line &lt;- cbind(variogramLine(vg_fit, maxdist = max(vg$dist)), id = &quot;Model&quot;) ggplot(vg, aes(x = dist, y = gamma, colour = id)) + geom_line(data = bind_rows(V_Env, .id=&quot;df&quot;), aes(x = dist, y = gamma, group = df), colour=&quot;grey&quot;) + geom_point() + geom_line(data = vg_Line, size = 0.8) + ylim(0,2.5) + annotation_custom(tableGrob(vg_fit_Table,rows = NULL), xmin = 20, xmax = 45, ymin = 0.1, ymax = 1) + ggtitle(&quot;Variogram&quot;) Interpolation - TransGaussian kriging using Box-Cox transforms (gstat) - SPDF &lt;- as_Spatial(SPDF) InRn_DL &lt;- as_Spatial(InRn_DL) lambda &lt;- 0 Pred_OK &lt;- krigeTg(Rn ~ 1, InRn_DL, SPDF, model = vg_fit, lambda = lambda, maxdist = 40, # km (great-circle distances) nmax = 100, nmin = 5) # [using ordinary kriging] # [generalized least squares trend estimation] # [using simple kriging] SPDF$OK_Pred &lt;- Pred_OK$var1TG.pred SPDF$OK_SD &lt;- sqrt(Pred_OK$var1TG.var) SPDF$OK_RSD &lt;- sqrt(Pred_OK$var1TG.var)/Pred_OK$var1TG.pred Plot predictions (grids cells of 0.025 x 0.025 degrees) InRn_Pred$OK_Pred &lt;- Pred_OK$var1TG.pred InRn_Pred$OK_SD &lt;- sqrt(Pred_OK$var1TG.var) InRn_Pred$OK_RSD &lt;- sqrt(Pred_OK$var1TG.var)/Pred_OK$var1TG.pred # Back to sf format InRn_DL &lt;- as(InRn_DL, &quot;sf&quot;) SPDF &lt;- as(SPDF, &quot;sf&quot;) # Breaks breaks &lt;- c(0, 50, 100, 200, 300, 500, max(InRn_Pred$OK_Pred, na.rm = T)) InRn_Pred &lt;- InRn_Pred %&gt;% mutate(OK_brks = cut(OK_Pred, breaks, include.lowest = T, right = F)) # Plot predictions cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) P_OK_Pred &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = InRn_Pred, aes(fill = OK_brks, color = OK_brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + scale_color_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + geom_sf(data = InRn_DL, cex = 0.5) + ggtitle(&quot;OK - Predictions&quot;) P_OK_Pred Summarize by grids cells of 10 km x 10 km ## Estimate the mean of the points in each grid cell of 10 km x 10 km ---- # (or municipalities, districts, ...) ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km)+ geom_sf(data = SPDF, col = 2, cex = 0.7) ## Intersect predictions (points - SPDF) and Grid cells of 10km x 10km ---- SPDF_Grids10km &lt;- st_intersection(SPDF, Grids_10km) summary(SPDF_Grids10km) # IDW_Pred OK_Pred OK_SD OK_RSD CELLCODE EOFORIGIN # Min. : 1 Min. : 8 Min. : 6.5 Min. :0.057 Length:4489 Min. :5120000 # 1st Qu.: 21 1st Qu.: 21 1st Qu.: 16.3 1st Qu.:0.435 Class :character 1st Qu.:5150000 # Median : 41 Median : 37 Median : 22.3 Median :0.697 Mode :character Median :5160000 # Mean : 65 Mean : 56 Mean : 28.6 Mean :0.714 Mean :5163836 # 3rd Qu.: 77 3rd Qu.: 68 3rd Qu.: 33.7 3rd Qu.:0.973 3rd Qu.:5180000 # Max. :1356 Max. :594 Max. :111.3 Max. :1.781 Max. :5210000 # # NOFORIGIN Id GID_0 NAME_0 geometry # Min. :3610000 387 : 65 Length:4489 Length:4489 POINT :4489 # 1st Qu.:3650000 388 : 65 Class :character Class :character epsg:NA : 0 # Median :3670000 390 : 65 Mode :character Mode :character +proj=long...: 0 # Mean :3674636 446 : 65 # 3rd Qu.:3700000 447 : 65 # Max. :3730000 476 : 65 # (Other):4099 Summarize (by Id) SPDF_Grids10km_Sum &lt;- SPDF_Grids10km %&gt;% group_by(Id) %&gt;% summarize(N = n(), IDW_AM = mean(IDW_Pred, na.rm = T), IDW_SD = sd(IDW_Pred, na.rm = T), OK_AM = mean(OK_Pred, na.rm = T), OK_SD = sd(OK_Pred, na.rm = T)) Add values to Grid cells of 10 x 10 km (Grids_10km_Sum) Grids_10km_Sum &lt;- left_join(Grids_10km_Sum %&gt;% as.data.frame(), SPDF_Grids10km_Sum %&gt;% as.data.frame(), by = &quot;Id&quot;) Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% st_sf(sf_column_name = &quot;geometry.x&quot;) summary(Grids_10km_Sum) # CELLCODE EOFORIGIN NOFORIGIN Id # Length:93 Min. :5120000 Min. :3610000 340 : 1 # Class :character 1st Qu.:5150000 1st Qu.:3640000 341 : 1 # Mode :character Median :5160000 Median :3670000 361 : 1 # Mean :5163871 Mean :3674516 362 : 1 # 3rd Qu.:5180000 3rd Qu.:3710000 363 : 1 # Max. :5210000 Max. :3740000 364 : 1 # (Other):87 # GID_0 NAME_0 N.x Case # Length:93 Length:93 Min. : 0.0 Min. :0.00 # Class :character Class :character 1st Qu.: 7.0 1st Qu.:0.00 # Mode :character Mode :character Median :12.0 Median :0.00 # Mean :10.8 Mean :0.77 # 3rd Qu.:14.0 3rd Qu.:1.00 # Max. :22.0 Max. :9.00 # NA&#39;s :7 # AM SD GM GSD MIN # Min. : 3 Min. : 1 Min. : 2 Min. :1.12 Min. : 0.3 # 1st Qu.: 19 1st Qu.: 19 1st Qu.: 11 1st Qu.:2.28 1st Qu.: 1.7 # Median : 39 Median : 39 Median : 24 Median :2.75 Median : 4.2 # Mean : 69 Mean : 68 Mean : 45 Mean :2.95 Mean : 11.4 # 3rd Qu.: 86 3rd Qu.: 77 3rd Qu.: 54 3rd Qu.:3.44 3rd Qu.: 11.3 # Max. :687 Max. :549 Max. :472 Max. :6.20 Max. :143.2 # NA&#39;s :7 NA&#39;s :11 NA&#39;s :7 NA&#39;s :11 NA&#39;s :7 # MAX AM_brks Prob Prob_brks N.y # Min. : 5 [0,25) :29 Min. : 0.0 [0,1) :29 Min. : 1.0 # 1st Qu.: 59 [25,50) :23 1st Qu.: 0.6 [1,5) :28 1st Qu.:38.0 # Median : 132 [50,75) : 9 Median : 2.8 [5,10) :13 Median :62.0 # Mean : 213 [75,100) : 9 Mean : 7.6 [10,20) :14 Mean :48.8 # 3rd Qu.: 230 [100,200):12 3rd Qu.: 9.7 [20,30) : 4 3rd Qu.:63.0 # Max. :1615 [200,687]: 4 Max. :79.8 [30,79.8]: 5 Max. :65.0 # NA&#39;s :7 NA&#39;s : 7 NA&#39;s :1 # IDW_AM IDW_SD OK_AM OK_SD # Min. : 9 Min. : 1.1 Min. : 12 Min. : 0.4 # 1st Qu.: 26 1st Qu.: 10.3 1st Qu.: 25 1st Qu.: 4.8 # Median : 46 Median : 17.2 Median : 37 Median : 10.8 # Mean : 67 Mean : 30.6 Mean : 56 Mean : 17.6 # 3rd Qu.: 84 3rd Qu.: 35.3 3rd Qu.: 74 3rd Qu.: 19.8 # Max. :425 Max. :220.5 Max. :340 Max. :132.7 # NA&#39;s :1 NA&#39;s :3 NA&#39;s :1 NA&#39;s :3 # geometry.x geometry.y geometry # POLYGON :93 GEOMETRYCOLLECTION: 7 GEOMETRYCOLLECTION: 1 # epsg:4326 : 0 MULTIPOINT :82 MULTIPOINT :90 # +proj=long...: 0 POINT : 4 POINT : 2 # epsg:4326 : 0 epsg:NA : 0 # +proj=long... : 0 +proj=long... : 0 # # Plot maps # Breaks breaks_IDW &lt;- c(0, 25, 50, 75, 100, 200, max(Grids_10km_Sum$IDW_AM, na.rm = T)) breaks_OK &lt;- c(0, 25, 50, 75, 100, 200, max(Grids_10km_Sum$OK_AM, na.rm = T)) Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% mutate(IDW_brks = cut(IDW_AM, breaks_IDW, include.lowest = T, right = F), OK_brks = cut(OK_AM , breaks_OK , include.lowest = T, right = F)) # Maps P_Grids10km_IDW &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km_Sum, aes(fill = IDW_brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + ggtitle(&quot;IDW - Predictions&quot;) P_Grids10km_OK &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km_Sum, aes(fill = OK_brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + ggtitle(&quot;OK - Predictions&quot;) # Plot maps grid.arrange(P_Grids10km_AM, P_Grids10km_IDW, P_Grids10km_OK, nrow = 1, ncol = 3) ## Export results to shape file (.shp) for GIS: InRn_Pred and Grids_10km_Sum #st_write(InRn_Pred, &quot;InRn_Pred.shp&quot;, delete_layer = TRUE) # overwrites #st_write(Grids_10km_Sum, &quot;Grids_10km_Sum.shp&quot;, delete_layer = TRUE) # overwrites "],["dose-map.html", "Chapter 7 Dose map", " Chapter 7 Dose map summary(Grids_10km_Sum$OK_AM) # Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s # 12 25 37 56 74 340 1 summary(Grids_10km_Sum$OK_SD) # Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s # 0.4 4.8 10.8 17.6 19.8 132.7 3 ## New dataframe with AM and SD ---- Dose &lt;- Grids_10km_Sum %&gt;% transmute(Id = Id, Rn_AM = OK_AM, Rn_SD = OK_SD, ) ## Dose [mSv/y] = CRn [Bq/m3] * FE * FO * TY [h/y] * FD [mSv / Bq.h.m-3] # Uncertainty MC simulations nsim &lt;- 100 MC_Sim &lt;- matrix(NA, nrow = length(Dose$Rn_AM), ncol = nsim) TY &lt;- 8760 for (i in 1:nsim) { Rn &lt;- truncnorm::rtruncnorm(length(Dose$Rn_AM), a = 0, b = Inf, mean = Dose$Rn_AM, sd = Dose$Rn_SD) # truncated: Rn &gt; 0 FE &lt;- rlnorm(1, meanlog = log(0.4), sdlog = log(1.15)) FO &lt;- rnorm(1, 0.8, 0.03) FD &lt;- rnorm(1, 9e-06, 1.5e-06) MC_Sim[,i] &lt;- Rn * FE * FO * TY * FD } MC_Sim &lt;- as.data.frame(MC_Sim) MC_Sim$Id &lt;- Dose$Id MC_Sim$Dose_AM &lt;- rowMeans(MC_Sim[,1:nsim]) MC_Sim$Dose_SD &lt;- apply(MC_Sim[,1:nsim], 1, sd) ## Add AM and SD of the MC simulations to the dose table ---- Dose &lt;- left_join(Dose %&gt;% as.data.frame(), MC_Sim[c(&quot;Id&quot;,&quot;Dose_AM&quot;,&quot;Dose_SD&quot;)] %&gt;% as.data.frame, by = &quot;Id&quot;) Dose &lt;- Dose %&gt;% st_sf(sf_column_name = &quot;geometry.x&quot;) ## Dose map ---- summary(Dose) # Id Rn_AM Rn_SD Dose_AM Dose_SD # 340 : 1 Min. : 12 Min. : 0.4 Min. :0.30 Min. :0.11 # 341 : 1 1st Qu.: 25 1st Qu.: 4.8 1st Qu.:0.63 1st Qu.:0.22 # 361 : 1 Median : 37 Median : 10.8 Median :0.96 Median :0.40 # 362 : 1 Mean : 56 Mean : 17.6 Mean :1.44 Mean :0.57 # 363 : 1 3rd Qu.: 74 3rd Qu.: 19.8 3rd Qu.:1.84 3rd Qu.:0.65 # 364 : 1 Max. :340 Max. :132.7 Max. :8.71 Max. :3.89 # (Other):87 NA&#39;s :1 NA&#39;s :3 NA&#39;s :3 NA&#39;s :3 # geometry.x # POLYGON :93 # epsg:4326 : 0 # +proj=long...: 0 # # # # P_Dose_AM &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Dose, aes(fill = Dose_AM)) + scale_fill_gradient(name = &quot;mSv/y&quot;, low = &quot;blue&quot;, high = &quot;red&quot;) + ggtitle(&quot;Radiation dose - AM&quot;) P_Dose_AM P_Dose_SD &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Dose, aes(fill = Dose_SD)) + scale_fill_gradient(name = &quot;mSv/y&quot;, low = &quot;blue&quot;, high = &quot;red&quot;) + ggtitle(&quot;Radiation dose - SD&quot;) P_Dose_SD grid.arrange(P_Dose_AM, P_Dose_SD, nrow = 1, ncol = 2) "],["interactive-maps.html", "Chapter 8 Interactive maps", " Chapter 8 Interactive maps library(leaflet) ## Name of municipalities Lithuania &lt;- readRDS(url(&quot;https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_2_sf.rds&quot;)) p_popup &lt;- paste(&quot;&lt;strong&gt; Municipality: &lt;/strong&gt;&quot;, Lithuania$NAME_2) leaflet() %&gt;% addPolygons(data = Lithuania, stroke = TRUE, weight = 2, fillColor = &quot;grey&quot;, fillOpacity = 0.5, popup = p_popup) %&gt;% addTiles() ## Plot the AM (of the OK predictions) by grid cells of 10 km x 10 km (Grids_10km_Sum) p_popup &lt;- paste(&quot;&lt;strong&gt; Id: &lt;/strong&gt;&quot;, Grids_10km_Sum$Id, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt; AM: &lt;/strong&gt;&quot;, round(Grids_10km_Sum$OK_AM, 2), &quot;Bq/m3&quot;) pal_fun &lt;- colorQuantile(&quot;YlOrRd&quot;, NULL, n = 6) Grids_10km_Sum %&gt;% leaflet() %&gt;% addTiles() %&gt;% addPolygons(# add/remove polygon borders stroke = TRUE, col = &quot;grey&quot;, weight = 2, # set fill color with function from above and value fillColor = ~pal_fun(OK_AM), # make it nicer fillOpacity = 0.8, smoothFactor = 0.5, popup = p_popup) ## Plot the OK predictions by grid cells of 0.01 x 0.01 degrees (InRn_Pred) p_popup &lt;- paste(&quot;&lt;strong&gt; InRn: &lt;/strong&gt;&quot;, round(InRn_Pred$OK_Pred), &quot;Bq/m3&quot;) pal_fun &lt;- colorBin(&quot;YlOrRd&quot;, InRn_Pred$OK_Pred, bins = c(0,50,100, 200, 300, 500, max(InRn_Pred$OK_Pred))) InRn_Pred %&gt;% leaflet() %&gt;% addTiles() %&gt;% addPolygons(stroke = TRUE, col= &quot;grey&quot;, weight = 0.1, fillColor = ~pal_fun(OK_Pred), fillOpacity = 0.8, smoothFactor = 0.5, popup = p_popup) %&gt;% addLegend(pal = pal_fun, values = ~OK_Pred, opacity = 1, labFormat = labelFormat(prefix = &quot;[&quot;, suffix = &quot;)&quot;, between = &quot;, &quot;, digits = 0), title = &quot;InRn [Bq/m3]&quot;) "],["references.html", "References", " References Asch, Kristine. 2003. The 1 : 5 Million International Geological Map of Europe and Adjacent Areas: Development and Implementation of a GIS-enabled Concept. Stuttgart, Germany: Geologisches Jahrbuch SA, Schweizerbart Science Publishers. "]]
