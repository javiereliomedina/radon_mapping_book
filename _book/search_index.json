[["index.html", "Radon mapping with R Prerequisites R session", " Radon mapping with R Javier El√≠o 2021-04-09 Prerequisites The data have been analysed with R (version 4.0.4) and Rstudio (versio 1.4.1106), and the book has been created with bookdown package. The required packages are automatically checked and installed if needed from CRAN. # Create an auxiliary function for checking if a package is installed, # install it if it is not, and load the package # (based on https://gist.github.com/stevenworthington/3178163) ipak &lt;- function(pkg){ new_pkg &lt;- pkg[!(pkg %in% installed.packages()[, &quot;Package&quot;])] if (length(new_pkg)) install.packages(new_pkg, dependencies = TRUE, repos = &quot;http://cran.us.r-project.org&quot;) sapply(pkg, require, character.only = TRUE) } # List of packages pkg &lt;- c(&quot;tidyverse&quot;, &quot;sf&quot;, &quot;sp&quot;, &quot;gstat&quot; ) # Check and install ipak(pkg) # You may also need to install the following packages #install.packages(c(&quot;MASS&quot;, &quot;StatDA&quot;, &quot;NADA&quot;, &quot;truncnorm&quot;, &quot;units&quot;, &quot;leaflet&quot;, &quot;ggspatial&quot;, &quot;gridExtra&quot;, &quot;rgdal&quot;)) R session #&gt; R version 4.0.4 (2021-02-15) #&gt; Platform: x86_64-w64-mingw32/x64 (64-bit) #&gt; Running under: Windows 10 x64 (build 17763) #&gt; #&gt; Matrix products: default #&gt; #&gt; locale: #&gt; [1] LC_COLLATE=English_United Kingdom.1252 #&gt; [2] LC_CTYPE=English_United Kingdom.1252 #&gt; [3] LC_MONETARY=English_United Kingdom.1252 #&gt; [4] LC_NUMERIC=C #&gt; [5] LC_TIME=English_United Kingdom.1252 #&gt; #&gt; attached base packages: #&gt; [1] stats graphics grDevices utils datasets methods base #&gt; #&gt; other attached packages: #&gt; [1] gstat_2.0-7 sp_1.4-5 sf_0.9-8 forcats_0.5.1 #&gt; [5] stringr_1.4.0 dplyr_1.0.5 purrr_0.3.4 readr_1.4.0 #&gt; [9] tidyr_1.1.3 tibble_3.1.0 ggplot2_3.3.3 tidyverse_1.3.0 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] Rcpp_1.0.6 lattice_0.20-41 lubridate_1.7.9.2 #&gt; [4] FNN_1.1.3 zoo_1.8-9 class_7.3-18 #&gt; [7] assertthat_0.2.1 digest_0.6.27 utf8_1.2.1 #&gt; [10] R6_2.5.0 cellranger_1.1.0 backports_1.2.1 #&gt; [13] reprex_1.0.0 evaluate_0.14 e1071_1.7-6 #&gt; [16] httr_1.4.2 pillar_1.5.1 rlang_0.4.10 #&gt; [19] readxl_1.3.1 rstudioapi_0.13 jquerylib_0.1.3 #&gt; [22] rmarkdown_2.7 munsell_0.5.0 proxy_0.4-25 #&gt; [25] broom_0.7.5 compiler_4.0.4 modelr_0.1.8 #&gt; [28] xfun_0.22 pkgconfig_2.0.3 htmltools_0.5.1.1 #&gt; [31] tidyselect_1.1.0 bookdown_0.21 intervals_0.15.2 #&gt; [34] spacetime_1.2-4 fansi_0.4.2 crayon_1.4.1 #&gt; [37] dbplyr_2.1.0 withr_2.4.1 grid_4.0.4 #&gt; [40] jsonlite_1.7.2 gtable_0.3.0 lifecycle_1.0.0 #&gt; [43] DBI_1.1.1 magrittr_2.0.1 units_0.7-1 #&gt; [46] scales_1.1.1 KernSmooth_2.23-18 cli_2.3.1 #&gt; [49] stringi_1.5.3 fs_1.5.0 xml2_1.3.2 #&gt; [52] bslib_0.2.4 xts_0.12.1 ellipsis_0.3.1 #&gt; [55] generics_0.1.0 vctrs_0.3.6 tools_4.0.4 #&gt; [58] glue_1.4.2 hms_1.0.0 yaml_2.2.1 #&gt; [61] colorspace_2.0-0 classInt_0.4-3 rvest_1.0.0 #&gt; [64] knitr_1.31 haven_2.3.1 sass_0.3.1 "],["read-data.html", "Chapter 1 Read data 1.1 Administrative divisions ( 1.2 Grids 10 x 10 km 1.3 Make our own grid (e.g. 0.1 x 0.1 degrees) 1.4 Geology 1:5M 1.5 Study area 1.6 Indoor radon (simulated data)", " Chapter 1 Read data 1.1 Administrative divisions ( I got Lithuania from www.gadm.org, but you may download the administrative areas of other countries Country &lt;- readRDS(url(&quot;https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_0_sf.rds&quot;)) County &lt;- readRDS(url(&quot;https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_1_sf.rds&quot;)) Muni &lt;- readRDS(url(&quot;https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_2_sf.rds&quot;)) 1.2 Grids 10 x 10 km Download from https://www.eea.europa.eu/data-and-maps/data/eea-reference-grids-2 EEA_Ref_grid_URL &lt;- &quot;https://www.eea.europa.eu/data-and-maps/data/eea-reference-grids-2/gis-files/lithuania-shapefile/at_download/file.zip&quot; temp &lt;- tempfile() temp2 &lt;- tempfile() download.file(EEA_Ref_grid_URL, temp) unzip(zipfile = temp, exdir = temp2) Grids_10km &lt;- read_sf(file.path(temp2, &quot;lt_10km.shp&quot;)) unlink(c(temp, temp2)) Grids_10km$Id &lt;- seq(1, length(Grids_10km$CELLCODE), 1) # Add new column with &quot;Id&quot; Grids_10km$Id &lt;- as.factor(Grids_10km$Id) # Stored as a vector of integer values st_crs(Grids_10km) # Coordinate Reference System #&gt; Coordinate Reference System: #&gt; User input: ETRS89 / ETRS-LAEA #&gt; wkt: #&gt; PROJCRS[&quot;ETRS89 / ETRS-LAEA&quot;, #&gt; BASEGEOGCRS[&quot;ETRS89&quot;, #&gt; DATUM[&quot;European Terrestrial Reference System 1989&quot;, #&gt; ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; ID[&quot;EPSG&quot;,4258]], #&gt; CONVERSION[&quot;unnamed&quot;, #&gt; METHOD[&quot;Lambert Azimuthal Equal Area&quot;, #&gt; ID[&quot;EPSG&quot;,9820]], #&gt; PARAMETER[&quot;Latitude of natural origin&quot;,52, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8801]], #&gt; PARAMETER[&quot;Longitude of natural origin&quot;,10, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8802]], #&gt; PARAMETER[&quot;False easting&quot;,4321000, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8806]], #&gt; PARAMETER[&quot;False northing&quot;,3210000, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8807]]], #&gt; CS[Cartesian,2], #&gt; AXIS[&quot;x&quot;,east, #&gt; ORDER[1], #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; AXIS[&quot;y&quot;,north, #&gt; ORDER[2], #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; ID[&quot;EPSG&quot;,3035]] st_crs(Country) # Coordinate Reference System #&gt; Coordinate Reference System: #&gt; User input: EPSG:4326 #&gt; wkt: #&gt; GEOGCRS[&quot;WGS 84&quot;, #&gt; DATUM[&quot;World Geodetic System 1984&quot;, #&gt; ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; CS[ellipsoidal,2], #&gt; AXIS[&quot;geodetic latitude (Lat)&quot;,north, #&gt; ORDER[1], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; AXIS[&quot;geodetic longitude (Lon)&quot;,east, #&gt; ORDER[2], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; USAGE[ #&gt; SCOPE[&quot;Horizontal component of 3D system.&quot;], #&gt; AREA[&quot;World.&quot;], #&gt; BBOX[-90,-180,90,180]], #&gt; ID[&quot;EPSG&quot;,4326]] Grids_10km &lt;- Grids_10km %&gt;% st_transform(4326) # Trandform coordinate system (from EPSG: 3035 to EPSG: 4326) st_crs(Grids_10km) # Coordinate Reference System #&gt; Coordinate Reference System: #&gt; User input: EPSG:4326 #&gt; wkt: #&gt; GEOGCRS[&quot;WGS 84&quot;, #&gt; DATUM[&quot;World Geodetic System 1984&quot;, #&gt; ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; CS[ellipsoidal,2], #&gt; AXIS[&quot;geodetic latitude (Lat)&quot;,north, #&gt; ORDER[1], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; AXIS[&quot;geodetic longitude (Lon)&quot;,east, #&gt; ORDER[2], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; USAGE[ #&gt; SCOPE[&quot;Horizontal component of 3D system.&quot;], #&gt; AREA[&quot;World.&quot;], #&gt; BBOX[-90,-180,90,180]], #&gt; ID[&quot;EPSG&quot;,4326]] st_crs(Country) # Coordinate Reference System #&gt; Coordinate Reference System: #&gt; User input: EPSG:4326 #&gt; wkt: #&gt; GEOGCRS[&quot;WGS 84&quot;, #&gt; DATUM[&quot;World Geodetic System 1984&quot;, #&gt; ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; CS[ellipsoidal,2], #&gt; AXIS[&quot;geodetic latitude (Lat)&quot;,north, #&gt; ORDER[1], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; AXIS[&quot;geodetic longitude (Lon)&quot;,east, #&gt; ORDER[2], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; USAGE[ #&gt; SCOPE[&quot;Horizontal component of 3D system.&quot;], #&gt; AREA[&quot;World.&quot;], #&gt; BBOX[-90,-180,90,180]], #&gt; ID[&quot;EPSG&quot;,4326]] Grids_10km &lt;- st_intersection(Grids_10km, Country) # Grids in the country plot(Grids_10km[&quot;Id&quot;]) 1.3 Make our own grid (e.g. 0.1 x 0.1 degrees) # Make regular grids (0.1 x 0.1) Grids &lt;- Country %&gt;% st_make_grid(cellsize = 0.1, what = &quot;polygons&quot;) %&gt;% st_sf() %&gt;% st_intersection(Country) %&gt;% # Name grids as &quot;g001&quot;, &quot;g002&quot; mutate(ID = paste0(&quot;g&quot;, stringr::str_pad(seq(1, nrow(.), 1), 3, pad = &quot;0&quot;))) # Centroid of the grid SPDF &lt;- st_centroid(Grids) plot(Country[&quot;NAME_0&quot;], reset = F, main = &quot;Lithuania: cells 0.1x0.1 degrees&quot;) plot(Grids, add = T, border = 2) plot(SPDF, add = T, col = &quot;blue&quot;) 1.4 Geology 1:5M Download from BGR (Asch 2003) IGME5000_url &lt;- &quot;https://download.bgr.de/bgr/Geologie/IGME5000/shp/IGME5000.zip&quot; temp &lt;- tempfile() temp2 &lt;- tempfile() download.file(IGME5000_url, temp) unzip(zipfile = temp, exdir = temp2) IGME5000 &lt;- read_sf(file.path(temp2, &quot;europe/data/IGME5000_europeEPSG3034shp_geology_poly_v01.shp&quot;)) unlink(c(temp, temp2)) st_crs(IGME5000) #&gt; Coordinate Reference System: #&gt; User input: ETRS89-extended / LCC Europe #&gt; wkt: #&gt; PROJCRS[&quot;ETRS89-extended / LCC Europe&quot;, #&gt; BASEGEOGCRS[&quot;ETRS89&quot;, #&gt; DATUM[&quot;European Terrestrial Reference System 1989&quot;, #&gt; ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; ID[&quot;EPSG&quot;,4258]], #&gt; CONVERSION[&quot;Europe Conformal 2001&quot;, #&gt; METHOD[&quot;Lambert Conic Conformal (2SP)&quot;, #&gt; ID[&quot;EPSG&quot;,9802]], #&gt; PARAMETER[&quot;Latitude of false origin&quot;,52, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8821]], #&gt; PARAMETER[&quot;Longitude of false origin&quot;,10, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8822]], #&gt; PARAMETER[&quot;Latitude of 1st standard parallel&quot;,35, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8823]], #&gt; PARAMETER[&quot;Latitude of 2nd standard parallel&quot;,65, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8824]], #&gt; PARAMETER[&quot;Easting at false origin&quot;,4000000, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8826]], #&gt; PARAMETER[&quot;Northing at false origin&quot;,2800000, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8827]]], #&gt; CS[Cartesian,2], #&gt; AXIS[&quot;northing (N)&quot;,north, #&gt; ORDER[1], #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; AXIS[&quot;easting (E)&quot;,east, #&gt; ORDER[2], #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; USAGE[ #&gt; SCOPE[&quot;Conformal mapping at scales of 1:500,000 and smaller.&quot;], #&gt; AREA[&quot;Europe - European Union (EU) countries and candidates. Europe - onshore and offshore: Albania; Andorra; Austria; Belgium; Bosnia and Herzegovina; Bulgaria; Croatia; Cyprus; Czechia; Denmark; Estonia; Faroe Islands; Finland; France; Germany; Gibraltar; Greece; Hungary; Iceland; Ireland; Italy; Kosovo; Latvia; Liechtenstein; Lithuania; Luxembourg; Malta; Monaco; Montenegro; Netherlands; North Macedonia; Norway including Svalbard and Jan Mayen; Poland; Portugal including Madeira and Azores; Romania; San Marino; Serbia; Slovakia; Slovenia; Spain including Canary Islands; Sweden; Switzerland; Turkey; United Kingdom (UK) including Channel Islands and Isle of Man; Vatican City State.&quot;], #&gt; BBOX[24.6,-35.58,84.17,44.83]], #&gt; ID[&quot;EPSG&quot;,3034]] st_crs(Country) #&gt; Coordinate Reference System: #&gt; User input: EPSG:4326 #&gt; wkt: #&gt; GEOGCRS[&quot;WGS 84&quot;, #&gt; DATUM[&quot;World Geodetic System 1984&quot;, #&gt; ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; CS[ellipsoidal,2], #&gt; AXIS[&quot;geodetic latitude (Lat)&quot;,north, #&gt; ORDER[1], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; AXIS[&quot;geodetic longitude (Lon)&quot;,east, #&gt; ORDER[2], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; USAGE[ #&gt; SCOPE[&quot;Horizontal component of 3D system.&quot;], #&gt; AREA[&quot;World.&quot;], #&gt; BBOX[-90,-180,90,180]], #&gt; ID[&quot;EPSG&quot;,4326]] IGME5000 &lt;- IGME5000 %&gt;% st_transform(4326) %&gt;% st_intersection(Country) st_crs(IGME5000) #&gt; Coordinate Reference System: #&gt; User input: EPSG:4326 #&gt; wkt: #&gt; GEOGCRS[&quot;WGS 84&quot;, #&gt; DATUM[&quot;World Geodetic System 1984&quot;, #&gt; ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; CS[ellipsoidal,2], #&gt; AXIS[&quot;geodetic latitude (Lat)&quot;,north, #&gt; ORDER[1], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; AXIS[&quot;geodetic longitude (Lon)&quot;,east, #&gt; ORDER[2], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; USAGE[ #&gt; SCOPE[&quot;Horizontal component of 3D system.&quot;], #&gt; AREA[&quot;World.&quot;], #&gt; BBOX[-90,-180,90,180]], #&gt; ID[&quot;EPSG&quot;,4326]] plot(IGME5000[&quot;AgeName&quot;]) 1.5 Study area I will focus the data analysis in a region of of 1x1 degrees # First: build a rectangle Area &lt;- matrix(NA, ncol = 2, nrow = 4) Area &lt;- as.data.frame(Area) names(Area) &lt;- c(&quot;X&quot;,&quot;Y&quot;) Area[1,] &lt;- c(23,55) Area[2,] &lt;- c(23,56) Area[3,] &lt;- c(24,56) Area[4,] &lt;- c(24,55) coordinates(Area) &lt;- ~X+Y Area &lt;- rbind(Area,Area[1,]) Area &lt;- Polygons(list(Polygon(Area)),ID=&quot;Area&quot;) Area &lt;- SpatialPolygons(list(Area)) Area &lt;- as(Area, &quot;sf&quot;) st_crs(Area) &lt;- st_crs(Country) plot(Country[&quot;NAME_0&quot;], axes = TRUE, reset = F) plot(Area, col = &quot;blue&quot;, add = T) # Second: intersect Area with all the data Country &lt;- st_intersection(Country, Area) County &lt;- st_intersection(County, Area) Muni &lt;- st_intersection(Muni, Area) Grids_10km &lt;- st_intersection(Grids_10km, Area) IGME5000 &lt;- st_intersection(IGME5000, Area) 1.6 Indoor radon (simulated data) Please be aware that I am using SIMULATED data, and therefore data interpretation is NOT real. Any coincidence with a real case (i.e. Lithuania) is casual. Data are only useful for training purpose, you may need to read your own data for data interpretation. set.seed(1) # Make the simulation reproducible # Radom points in the study area N &lt;- 1000 X &lt;- runif(N,23.0001,23.9999) Y &lt;- runif(N,55.0001,55.9999) points &lt;- cbind(X,Y) points &lt;- as.data.frame(points) coordinates(points) &lt;- ~X+Y proj4string(points) &lt;- CRS(&quot;EPSG:4326&quot;) points &lt;- as(points, &quot;sf&quot;) points &lt;- st_intersection(points, Country) points &lt;- as_Spatial(points) # define the gstat object (spatial model) library(gstat) g_dummy &lt;- gstat(formula = z ~ 1, locations = ~ X + Y, dummy = T, beta = 3, model = vgm(psill = 1.5, model = &quot;Exp&quot;, range = 10, nugget = 0.5), nmax = 100) # Simulations based on the gstat object points &lt;- predict(g_dummy, newdata = points, nsim = 1) #&gt; [using unconditional Gaussian simulation] points$Rn &lt;- exp(points$sim1) # Final result: Simulated indoor radon dataset (InRn) in Bq m-3 InRn &lt;- points[,&quot;Rn&quot;] # Detection Limit (DL): 10 Bq m-3 (replaced by half of the Limit of Detection) InRn[InRn$Rn &lt;= 10,] &lt;- 5 InRn &lt;- as(InRn, &quot;sf&quot;) %&gt;% st_transform(crs = &quot;EPSG:4326&quot;) "],["exploratory-data-analysis.html", "Chapter 2 Exploratory data analysis 2.1 Histogram (Rn) 2.2 Spatial distribution", " Chapter 2 Exploratory data analysis 2.1 Histogram (Rn) hist(InRn$Rn, prob = T, col = &quot;red&quot;, breaks = 10, main = &quot;Histogram Indoor Radon&quot;, xlab = expression(&quot;Rn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) StatDA::qqplot.das(InRn$Rn, distribution = &quot;norm&quot;, col = 1, envelope = 0.95, datax = T, main = &quot;Q-Q plot (InRn)&quot;) #&gt; &#39;RandomFieldsUtils&#39; will use OMP #&gt; &#39;RandomFields&#39; will use OMP ## Box-Cox transformation ---- BCT &lt;- MASS::boxcox(InRn$Rn ~ 1, lambda = seq(-1, 1, 1/100)) title(&quot;Box-Cox Transformation&quot;) BCT &lt;- as.data.frame(BCT) # lambda &lt;- BCT[BCT$y == max(BCT$y), ]$x # -0.17 # InRn$BCT &lt;- (InRn$Rn^lambda-1)/lambda lambda &lt;- 0 InRn$LogRn &lt;- log(InRn$Rn) ## Histogram (logRn) ---- hist(InRn$LogRn, col = &quot;red&quot;, breaks = 30, prob = T, main = &quot;Histogram Indoor Radon&quot;, xlab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) StatDA::qqplot.das(InRn$LogRn, distribution = &quot;norm&quot;, col = 1, envelope = 0.95,datax=T, main = &quot;Q-Q plot (log InRn)&quot;) ## ROS: ROBUST IMPUTATION METHOD ---- DL &lt;- 10 InRn_DL &lt;- InRn InRn_DL$Rn_Cen &lt;- &quot;FALSE&quot; InRn_DL[InRn_DL$Rn &lt;= DL,][&quot;Rn_Cen&quot;] &lt;- &quot;TRUE&quot; InRn_DL$Rn_Cen &lt;- as.logical(InRn_DL$Rn_Cen) ROS &lt;- NADA::ros(InRn_DL$Rn, InRn_DL$Rn_Cen, forwardT = &quot;log&quot;) ROS &lt;- as.data.frame(ROS) # Replace Dl by the modeled values InRn_DL[InRn_DL$Rn_Cen == &quot;TRUE&quot;,][&quot;Rn&quot;] &lt;- ROS[ROS$censored == &quot;TRUE&quot;,][&quot;modeled&quot;] InRn_DL$LogRn &lt;- log(InRn_DL$Rn) ## q-q plots ---- par(mfrow=c(1,2)) StatDA::qqplot.das(InRn$LogRn, distribution = &quot;norm&quot;, col = 1, envelope = 0.95, datax = T, main = &quot;Original data&quot;) StatDA::qqplot.das(InRn_DL$LogRn, distribution = &quot;norm&quot;, col = 1, envelope = 0.95, datax = T, main = &quot;After ROS&quot;) mean(InRn$Rn) #&gt; [1] 64.08896 sd(InRn$Rn) #&gt; [1] 126.327 exp(mean(InRn$LogRn)) #&gt; [1] 25.74388 exp(sd(InRn$LogRn)) #&gt; [1] 3.683979 RL &lt;- 200 # Bq m-3 100*(1 - pnorm(log(RL), mean = mean(InRn$LogRn), sd = sd(InRn$LogRn))) #&gt; [1] 5.795368 mean(InRn_DL$Rn) #&gt; [1] 64.13248 sd(InRn_DL$Rn) #&gt; [1] 126.3137 exp(mean(InRn_DL$LogRn)) #&gt; [1] 24.76532 exp(sd(InRn_DL$LogRn)) #&gt; [1] 4.043691 100*(1-pnorm(log(RL), mean = mean(InRn_DL$LogRn), sd = sd(InRn_DL$LogRn))) #&gt; [1] 6.744583 ## Histogram (logRn) ---- par(mfrow=c(1,2)) hist(InRn$LogRn, col = &quot;red&quot;, breaks = 30, prob = T, ylim = c(0, 0.5), main = &quot;Origical data&quot;, xlab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) hist(InRn_DL$LogRn, col = &quot;red&quot;, breaks = 30, prob = T, ylim = c(0, 0.5), main = &quot;After ROS&quot;, xlab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) ## Histogram, boxplot, q-q plot ---- par(mfrow = c(1,3)) hist(InRn_DL$LogRn, col = &quot;red&quot;, breaks = 30, prob = T, main = &quot;Histogram&quot;, xlab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) lines(density(InRn_DL$LogRn), lwd = 1) boxplot(InRn_DL$LogRn, notch = TRUE, col=2, varwidth = TRUE, main = &quot;Boxplot&quot;, ylab = &quot;Lognormal transformation&quot;, xlab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;)) StatDA::qqplot.das(InRn_DL$LogRn, distribution = &quot;norm&quot;, col = 1, envelope = 0.95, datax = T, ylab = &quot;Observed Value&quot;, xlab = &quot;Expected Normal Value&quot;, main = (&quot;Normal Q-Q plot&quot;), line = &quot;quartiles&quot;, pch = 3, cex = 0.7, xaxt = &quot;s&quot;) 2.2 Spatial distribution ## Plot InRn measurements in Bq/m3 (with ggplot2) ---- P_Rn &lt;- ggplot() + geom_sf(data = Grids_10km) + geom_sf(data = InRn_DL, aes(color = Rn)) + scale_color_gradient(name = &quot;Bq/m3&quot;, low = &quot;blue&quot;, high = &quot;red&quot;) + ggtitle(&quot;Indoor radon measurements (Simulated)&quot;) P_Rn ## Change intervale in the Rn scale ---- breaks &lt;- c(0, 50, 100, 200, 300, 500, max(InRn_DL$Rn)) InRn_DL &lt;- InRn_DL %&gt;% mutate(brks = cut(Rn, breaks, include.lowest = T, right = F)) cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) # cols &lt;- terrain.colors(6) # cols &lt;- heat.colors(6, alpha = 1) # cols &lt;- colorRampPalette(c(&quot;yellow&quot;, &quot;red&quot;))(6) P_Rn_brks &lt;- ggplot() + geom_sf(data = Grids_10km) + geom_sf(data = InRn_DL, aes(fill = brks, color = brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + scale_color_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + ggtitle(&quot;Indoor radon measurements (Simulated)&quot;) P_Rn_brks ## Plot if Rn is higher than Reference level (1) or not (0) ---- # Transform InRn to: 1 if Rn &gt;= RL or 0 if Rn &lt; RL (&quot;Case&quot;) RL &lt;- 200 # Bq m-3 InRn_DL &lt;- InRn_DL %&gt;% mutate(Case = as.factor(ifelse(Rn &gt;= 200, yes = 1, no = 0))) P_Cases &lt;- ggplot() + geom_sf(data = Grids_10km) + geom_sf(data = InRn_DL, aes(fill = Case, color = Case)) + scale_fill_manual( name = &quot;Bq/m3&quot;, labels = c(&quot;&lt; 200&quot;,&quot;&gt;= 200&quot;), values = c(&quot;lightgreen&quot;, &quot;red&quot;)) + scale_color_manual(name = &quot;Bq/m3&quot;, labels = c(&quot;&lt; 200&quot;,&quot;&gt;= 200&quot;), values = c(&quot;lightgreen&quot;, &quot;red&quot;)) + # theme(legend.position = &quot;none&quot;) + ggtitle(&quot;Indoor radon measurements (Simulated)&quot;) P_Cases ## Kernel density plots ---- # The resulting density map is noisier for small bandwidth (h) # and smoother for large bandwidth (h). # A rule-of-thumb for an optimal value is h  max(sx, sy)*0.7*n^-0.2 # where n is the number of points, # and sx and sy the standard deviations of x- and y- coordinates of the points # See printed version of the EU Atlas for further information (in progress) # 2.4. Statistics, measurements, maping (part wirtten by P. Bossew) # All dwelling sampled (e.g. for detecting possible clusters; avoid overplotting) H &lt;- st_coordinates(InRn_DL) h &lt;- max(sd(H[,&quot;X&quot;]), sd(H[,&quot;Y&quot;])) * 0.7 * nrow(H)^-0.2 KP_all &lt;- InRn_DL %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% ggplot() + geom_sf(data = Grids_10km) + stat_density_2d(aes(X, Y, fill = ..level.., alpha = ..level..), h = h, geom = &quot;polygon&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme(legend.position = &quot;none&quot;) + #geom_sf(data = InRn_DL, size = .1) + ggtitle(&quot;Kernel density plots (all data)&quot;) + labs(x = &quot;&quot;, y = &quot;&quot;) KP_all # Only dwellings with InRn &gt; RL (cases == 1) H &lt;- st_coordinates(filter(InRn_DL, Case == 1)) h &lt;- max(sd(H[,&quot;X&quot;]), sd(H[,&quot;Y&quot;])) * 0.7 * nrow(H)^-0.2 KP_Cases &lt;- InRn_DL %&gt;% filter(Case == 1) %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% ggplot() + geom_sf(data = Grids_10km) + stat_density_2d(aes(X, Y, fill = ..level.., alpha = ..level..), h = h, geom = &quot;polygon&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme(legend.position = &quot;none&quot;) + geom_sf(data = filter(InRn_DL, Case == 1), size = .1) + ggtitle(&quot;Kernel density plots (InRn &gt;= 200 Bq/m3)&quot;) + labs(x = &quot;&quot;, y = &quot;&quot;) KP_Cases # Only dwellings with InRn &lt; RL (cases) H &lt;- st_coordinates(filter(InRn_DL, Case == 0)) h &lt;- max(sd(H[,&quot;X&quot;]), sd(H[,&quot;Y&quot;])) * 0.7 * nrow(H)^-0.2 KP_No_Cases &lt;- InRn_DL %&gt;% filter(Case == 0) %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% ggplot() + geom_sf(data = Grids_10km) + stat_density_2d(aes(X, Y, fill = ..level.., alpha = ..level..), h = h, geom = &quot;polygon&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme(legend.position = &quot;none&quot;) + geom_sf(data = filter(InRn_DL, Case == 0), size = .1) + ggtitle(&quot;Kernel density plots (InRn &lt; 200 Bq/m3)&quot;) + labs(x = &quot;&quot;, y = &quot;&quot;) KP_No_Cases # Plot two (or more) figures in one library(gridExtra) grid.arrange(KP_No_Cases, KP_Cases, nrow = 2) grid.arrange(KP_No_Cases, KP_Cases, nrow = 1) # InRn vs Geologia ---- P_BG &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = IGME5000, aes(fill = AgeName), colour = NA) + geom_sf(data = InRn_DL, aes(), colour = 1, cex = 0.8) + scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) + ggtitle(&quot;Geology 1:1M&quot;) P_BG ## Intersect ---- InRn_DL_BG &lt;- st_intersection(InRn_DL, IGME5000) ## Boxplots ---- par(mar = c(9,5,3,0.5), oma = c(0, 0.5, 0.5, 0.5), mfrow = c(1,1)) boxplot(LogRn ~ AgeName, InRn_DL_BG, col = 2, varwidth = TRUE, notch = T, las = 2, ylab = expression(&quot;LogRn &quot; * &quot;[Bq&quot; * m^-3 * &quot;]&quot;), xlab = &quot;&quot;, main = &quot;Geology (AgeName)&quot;) # ANOVA ---- lm_BG &lt;- lm(LogRn ~ AgeName, InRn_DL_BG) summary(lm_BG) #&gt; #&gt; Call: #&gt; lm(formula = LogRn ~ AgeName, data = InRn_DL_BG) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -3.9519 -0.9035 -0.0294 0.9739 4.0480 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 2.8219 0.1038 27.192 &lt; 2e-16 *** #&gt; AgeNameEarly Triassic 0.2549 0.1363 1.871 0.061688 . #&gt; AgeNameLate Devonian 0.5174 0.1325 3.904 0.000101 *** #&gt; AgeNameLate Jurassic 0.8586 0.1366 6.283 4.96e-10 *** #&gt; AgeNameLate Permian -0.2470 0.1838 -1.344 0.179315 #&gt; AgeNameMiddle Jurassic 0.7674 0.4641 1.653 0.098557 . #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 1.357 on 994 degrees of freedom #&gt; Multiple R-squared: 0.06134, Adjusted R-squared: 0.05661 #&gt; F-statistic: 12.99 on 5 and 994 DF, p-value: 2.894e-12 anova(lm_BG) #&gt; Analysis of Variance Table #&gt; #&gt; Response: LogRn #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; AgeName 5 119.61 23.9222 12.99 2.894e-12 *** #&gt; Residuals 994 1830.49 1.8415 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 "],["summary-statistics.html", "Chapter 3 Summary statistics", " Chapter 3 Summary statistics ## InRn by grids of 10 x 10 km (summry: N, AM, SD, GM, GSD) ---- InRn_DL &lt;- st_intersection(InRn_DL, Grids_10km) str(InRn_DL) #&gt; Classes &#39;sf&#39; and &#39;data.frame&#39;: 1000 obs. of 12 variables: #&gt; $ Rn : num 5.113 0.785 1.763 6.323 36.349 ... #&gt; $ LogRn : num 1.632 -0.242 0.567 1.844 3.593 ... #&gt; $ Rn_Cen : logi TRUE TRUE TRUE TRUE FALSE FALSE ... #&gt; $ brks : Factor w/ 6 levels &quot;[0,50)&quot;,&quot;[50,100)&quot;,..: 1 1 1 1 1 4 1 3 2 1 ... #&gt; $ Case : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 1 1 1 2 1 1 1 1 ... #&gt; $ CELLCODE : chr &quot;10kmE512N372&quot; &quot;10kmE513N367&quot; &quot;10kmE513N367&quot; &quot;10kmE513N367&quot; ... #&gt; $ EOFORIGIN: num 5120000 5130000 5130000 5130000 5130000 5130000 5130000 5130000 5130000 5130000 ... #&gt; $ NOFORIGIN: num 3720000 3670000 3670000 3670000 3680000 3680000 3680000 3680000 3680000 3690000 ... #&gt; $ Id : Factor w/ 1022 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 341 362 362 362 363 363 363 363 363 364 ... #&gt; $ GID_0 : chr &quot;LTU&quot; &quot;LTU&quot; &quot;LTU&quot; &quot;LTU&quot; ... #&gt; $ NAME_0 : chr &quot;Lithuania&quot; &quot;Lithuania&quot; &quot;Lithuania&quot; &quot;Lithuania&quot; ... #&gt; $ geometry :sfc_POINT of length 1000; first list element: &#39;XY&#39; num 23 56 #&gt; - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; #&gt; - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA ... #&gt; ..- attr(*, &quot;names&quot;)= chr [1:11] &quot;Rn&quot; &quot;LogRn&quot; &quot;Rn_Cen&quot; &quot;brks&quot; ... InRn_DL$Case &lt;- as.numeric(as.character(InRn_DL$Case)) InRn_Summary_Grids10km &lt;- InRn_DL %&gt;% group_by(Id) %&gt;% summarize(N = n(), Case = sum(Case), AM = mean(Rn), SD = sd(Rn), GM = exp(mean((LogRn))), GSD = exp(sd(LogRn)), MIN = min(Rn), MAX = max(Rn)) ## Add summary to grids of 10x10 km ---- Grids_10km_Sum &lt;- left_join(Grids_10km %&gt;% as.data.frame(), InRn_Summary_Grids10km %&gt;% as.data.frame(), by = &quot;Id&quot;) Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% st_sf(sf_column_name = &quot;geometry.x&quot;) %&gt;% mutate(N = replace_na(N, 0)) summary(Grids_10km_Sum) #&gt; CELLCODE EOFORIGIN NOFORIGIN Id #&gt; Length:93 Min. :5120000 Min. :3610000 340 : 1 #&gt; Class :character 1st Qu.:5150000 1st Qu.:3640000 341 : 1 #&gt; Mode :character Median :5160000 Median :3670000 361 : 1 #&gt; Mean :5163871 Mean :3674516 362 : 1 #&gt; 3rd Qu.:5180000 3rd Qu.:3710000 363 : 1 #&gt; Max. :5210000 Max. :3740000 364 : 1 #&gt; (Other):87 #&gt; GID_0 NAME_0 N Case #&gt; Length:93 Length:93 Min. : 0.00 Min. :0.0000 #&gt; Class :character Class :character 1st Qu.: 7.00 1st Qu.:0.0000 #&gt; Mode :character Mode :character Median :12.00 Median :0.0000 #&gt; Mean :10.75 Mean :0.7674 #&gt; 3rd Qu.:14.00 3rd Qu.:1.0000 #&gt; Max. :22.00 Max. :9.0000 #&gt; NA&#39;s :7 #&gt; AM SD GM GSD #&gt; Min. : 2.957 Min. : 0.9767 Min. : 2.061 Min. :1.124 #&gt; 1st Qu.: 18.881 1st Qu.: 19.1492 1st Qu.: 11.320 1st Qu.:2.276 #&gt; Median : 38.933 Median : 39.4056 Median : 24.043 Median :2.753 #&gt; Mean : 69.400 Mean : 67.9795 Mean : 44.716 Mean :2.947 #&gt; 3rd Qu.: 85.645 3rd Qu.: 77.3011 3rd Qu.: 53.733 3rd Qu.:3.437 #&gt; Max. :686.712 Max. :548.5429 Max. :472.351 Max. :6.198 #&gt; NA&#39;s :7 NA&#39;s :11 NA&#39;s :7 NA&#39;s :11 #&gt; MIN MAX geometry.x #&gt; Min. : 0.323 Min. : 5.012 POLYGON :93 #&gt; 1st Qu.: 1.745 1st Qu.: 58.887 epsg:4326 : 0 #&gt; Median : 4.233 Median : 131.628 +proj=long...: 0 #&gt; Mean : 11.410 Mean : 212.524 #&gt; 3rd Qu.: 11.316 3rd Qu.: 230.376 #&gt; Max. :143.200 Max. :1615.331 #&gt; NA&#39;s :7 NA&#39;s :7 #&gt; geometry.y #&gt; GEOMETRYCOLLECTION: 7 #&gt; MULTIPOINT :82 #&gt; POINT : 4 #&gt; epsg:4326 : 0 #&gt; +proj=long... : 0 #&gt; #&gt; ## Plot number of data in each grid cell ---- cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) P_Grids10km_N &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km_Sum, aes(fill = N)) + scale_fill_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) + ggtitle(&quot;Number of data&quot;) P_Grids10km_N ## Plot arithmetic mean ---- max(Grids_10km_Sum$AM, na.rm = T) #&gt; [1] 686.7122 breaks &lt;- c(0, 25, 50, 75, 100, 200, max(Grids_10km_Sum$AM, na.rm = T)) Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% mutate(AM_brks = cut(AM, breaks, include.lowest = T, right = F)) cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) P_Grids10km_AM &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km_Sum, aes(fill = AM_brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + ggtitle(&quot;Arithmetic mean&quot;) P_Grids10km_AM ## Probabilistic maps ---- # Probability of having an indoor radon concentration above the national reference level (e.g. RL = 200 Bq m-3) # Based solely on the indoor radon measurements in each grid of 10x10 km, # and assuming data independence and lognormality str(Grids_10km_Sum) #&gt; Classes &#39;sf&#39; and &#39;data.frame&#39;: 93 obs. of 17 variables: #&gt; $ CELLCODE : chr &quot;10kmE512N371&quot; &quot;10kmE512N372&quot; &quot;10kmE513N366&quot; &quot;10kmE513N367&quot; ... #&gt; $ EOFORIGIN : num 5120000 5120000 5130000 5130000 5130000 5130000 5130000 5130000 5130000 5130000 ... #&gt; $ NOFORIGIN : num 3710000 3720000 3660000 3670000 3680000 3690000 3700000 3710000 3720000 3730000 ... #&gt; $ Id : Factor w/ 1022 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 340 341 361 362 363 364 365 366 367 368 ... #&gt; $ GID_0 : chr &quot;LTU&quot; &quot;LTU&quot; &quot;LTU&quot; &quot;LTU&quot; ... #&gt; $ NAME_0 : chr &quot;Lithuania&quot; &quot;Lithuania&quot; &quot;Lithuania&quot; &quot;Lithuania&quot; ... #&gt; $ N : num 0 1 0 3 5 12 19 15 10 0 ... #&gt; $ Case : num NA 0 NA 0 1 0 0 0 0 NA ... #&gt; $ AM : num NA 5.11 NA 2.96 97.47 ... #&gt; $ SD : num NA NA NA 2.96 91.43 ... #&gt; $ GM : num NA 5.11 NA 2.06 56.42 ... #&gt; $ GSD : num NA NA NA 2.86 3.79 ... #&gt; $ MIN : num NA 5.113 NA 0.785 8.032 ... #&gt; $ MAX : num NA 5.11 NA 6.32 205.46 ... #&gt; $ geometry.x:sfc_POLYGON of length 93; first list element: List of 1 #&gt; ..$ : num [1:4, 1:2] 23 23 23 23 55.9 ... #&gt; ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;POLYGON&quot; &quot;sfg&quot; #&gt; $ geometry.y:sfc_GEOMETRY of length 93; first list element: list() #&gt; ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;GEOMETRYCOLLECTION&quot; &quot;sfg&quot; #&gt; $ AM_brks : Factor w/ 6 levels &quot;[0,25)&quot;,&quot;[25,50)&quot;,..: NA 1 NA 1 4 1 1 2 1 NA ... #&gt; - attr(*, &quot;sf_column&quot;)= chr &quot;geometry.x&quot; #&gt; - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA ... #&gt; ..- attr(*, &quot;names&quot;)= chr [1:15] &quot;CELLCODE&quot; &quot;EOFORIGIN&quot; &quot;NOFORIGIN&quot; &quot;Id&quot; ... # 1st: estimated Prob[InRn &gt; 200 Bq m-3] RL &lt;- 200 Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% mutate(Prob = 100*(1-pnorm(log(RL), mean = log(GM), sd = log(GSD)))) # 2nd: Replace values in grids with less than n data (i.e. N &lt; 5) by a modeled value # Generate the points for the interpolation (centroid) DCen &lt;- st_centroid(Grids_10km_Sum) # Inverse distance weighted (IDW) interpolation Prob_IDW &lt;- idw(Prob ~ 1, filter(DCen, N &gt; 5), newdata = filter(DCen, N &lt;= 5), nmax = 10, idp = 2 ) #&gt; [inverse distance weighted interpolation] # Replace values by the modeled values Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% mutate(Prob = replace(Prob, N &lt;= 5, Prob_IDW$var1.pred)) # Plot maps breaks &lt;- c(0, 1, 5, 10, 20, 30, max(Grids_10km_Sum$Prob)) Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% mutate(Prob_brks = cut(Prob, breaks, include.lowest = T, right = F)) cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) P_Grids10km_Prob &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km_Sum, aes(fill = Prob_brks)) + scale_fill_manual(name = &quot;%&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + ggtitle(&quot;Prob[InRn &gt; 200 Bq m-3]&quot;) P_Grids10km_Prob "],["interpolation.html", "Chapter 4 Interpolation 4.1 Prediction by grids of 0.015 x 0.015 degrees 4.2 Inverse distance weighted interpolation (IDW) 4.3 Ordinary Kriging", " Chapter 4 Interpolation 4.1 Prediction by grids of 0.015 x 0.015 degrees InRn_Pred &lt;- st_make_grid(Country, cellsize = .015, what = &quot;polygons&quot;) InRn_Pred &lt;- st_sf(InRn_Pred) SPDF &lt;- st_centroid(InRn_Pred) # predict in the center of the grid plot(InRn_Pred, reset = F) plot(SPDF, add = T, col = 2, pch = 16, cex = 0.7) 4.2 Inverse distance weighted interpolation (IDW) ### Optimal idp (10 k-fold Croos Validation) ---- data &lt;- InRn_DL res &lt;- numeric() IDP_RMSE &lt;- numeric() idp &lt;- seq(1,4,0.25) k &lt;- 10 folds &lt;- sample(x = 1:k, size = length(data$Rn), replace = TRUE) CV &lt;- matrix(NA,length(idp),2) for (j in 1:length(idp)) { for (i in 1:k) { m_model &lt;- data[folds != i, ] m_valid &lt;- data[folds == i, ] m_valid_pred &lt;- idw(Rn ~ 1 , m_model, m_valid, nmax = 100, maxdist = 40, nmin = 5, idp = idp[j]) res &lt;- m_valid$Rn - m_valid_pred$var1.pred IDP_RMSE[i] &lt;- sqrt(mean(res^2)) } CV[j,1] &lt;- idp[j] CV[j,2] &lt;- sqrt(mean(IDP_RMSE^2)) } #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] #&gt; [inverse distance weighted interpolation] CV &lt;- as.data.frame(CV) names(CV) &lt;- c(&quot;idp&quot;,&quot;RSME&quot;) plot(RSME ~ idp, CV) lines(RSME ~ idp, CV, col = 2) axis(1, labels = F, at = seq(0,10,0.5)) abline(v = seq(0,4,0.25), lty = 2, lwd = 1.5, col=&quot;gray&quot;) abline(h = seq(100,200,2), lty = 2, lwd = 1.5, col = &quot;gray&quot;) title(&quot;10-fold cross-validation&quot;) IDW (optimal idp = 2) Pred_IDW &lt;- idw(Rn ~ 1 , InRn_DL, SPDF, nmax = 100, maxdist = 40, # km; Unprojected data: great-circle distance; For projected data Euclidian distances are computed nmin = 5, idp = 2) #&gt; [inverse distance weighted interpolation] SPDF$IDW_Pred &lt;- Pred_IDW$var1.pred Plot map (grids cells of 0.015 x 0.015 degrees) InRn_Pred$IDW_Pred &lt;- Pred_IDW$var1.pred # Breaks breaks &lt;- c(0, 50, 100, 200, 300, 500, max(InRn_Pred$IDW_Pred, na.rm = T)) InRn_Pred &lt;- InRn_Pred %&gt;% mutate(IDW_brks = cut(IDW_Pred, breaks, include.lowest = T, right = F)) # Plot predictions cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) P_IDW_Pred &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = InRn_Pred, aes(fill = IDW_brks, color = IDW_brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + scale_color_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + geom_sf(data = InRn_DL, cex = 0.5) + ggtitle(&quot;IDW - Predictions&quot;) P_IDW_Pred 4.3 Ordinary Kriging ### Variogram (gstat) ---- vg &lt;- variogram(LogRn ~ 1, InRn_DL) # great-circle distances (km) vg_fit_Sph &lt;- fit.variogram(vg, model = vgm(&quot;Sph&quot;)) vg_fit_Exp &lt;- fit.variogram(vg, vgm(&quot;Exp&quot;)) plot(gamma ~ dist, vg, ylim = c(0, 1.05*max(vg$gamma)), col = 1, ylab = &quot;semivariance&quot;, xlab = &#39;distance&#39;, main = &quot;Variogram&quot;) lines(variogramLine(vg_fit_Sph, 100), col = &#39;red&#39;) lines(variogramLine(vg_fit_Exp, 100), col = &#39;blue&#39;) vg_fit &lt;- vg_fit_Exp Test: Random permutations (100 random variograms) V_Env &lt;- list() nsim &lt;- 100 for (i in 1:nsim) { RP &lt;- InRn_DL RP$LogRn &lt;- sample(InRn_DL$LogRn) g_RP &lt;- gstat(formula = LogRn ~ 1, data = RP) vg_RP &lt;- variogram(g_RP, cressie = F) V_Env[[i]] &lt;- vg_RP } vg_fit_Table &lt;- data.frame(Model = vg_fit$model, psill = round(vg_fit$psill, 2), range = round(vg_fit$range, 2), kappa = round(vg_fit$kappa, 2) ) vg_Line &lt;- cbind(variogramLine(vg_fit, maxdist = max(vg$dist)), id = &quot;Model&quot;) ggplot(vg, aes(x = dist, y = gamma, colour = id)) + geom_line(data = bind_rows(V_Env, .id=&quot;df&quot;), aes(x = dist, y = gamma, group = df), colour=&quot;grey&quot;) + geom_point() + geom_line(data = vg_Line, size = 0.8) + ylim(0,2.5) + annotation_custom(tableGrob(vg_fit_Table,rows = NULL), xmin = 20, xmax = 45, ymin = 0.1, ymax = 1) + ggtitle(&quot;Variogram&quot;) Interpolation - TransGaussian kriging using Box-Cox transforms (gstat) - SPDF &lt;- as_Spatial(SPDF) InRn_DL &lt;- as_Spatial(InRn_DL) lambda &lt;- 0 Pred_OK &lt;- krigeTg(Rn ~ 1, InRn_DL, SPDF, model = vg_fit, lambda = lambda, maxdist = 40, # km (great-circle distances) nmax = 100, nmin = 5) #&gt; [using ordinary kriging] #&gt; [generalized least squares trend estimation] #&gt; [using simple kriging] SPDF$OK_Pred &lt;- Pred_OK$var1TG.pred SPDF$OK_SD &lt;- sqrt(Pred_OK$var1TG.var) SPDF$OK_RSD &lt;- sqrt(Pred_OK$var1TG.var)/Pred_OK$var1TG.pred Plot predictions (grids cells of 0.025 x 0.025 degrees) InRn_Pred$OK_Pred &lt;- Pred_OK$var1TG.pred InRn_Pred$OK_SD &lt;- sqrt(Pred_OK$var1TG.var) InRn_Pred$OK_RSD &lt;- sqrt(Pred_OK$var1TG.var)/Pred_OK$var1TG.pred # Back to sf format InRn_DL &lt;- as(InRn_DL, &quot;sf&quot;) SPDF &lt;- as(SPDF, &quot;sf&quot;) # Breaks breaks &lt;- c(0, 50, 100, 200, 300, 500, max(InRn_Pred$OK_Pred, na.rm = T)) InRn_Pred &lt;- InRn_Pred %&gt;% mutate(OK_brks = cut(OK_Pred, breaks, include.lowest = T, right = F)) # Plot predictions cols &lt;- colorRampPalette(c(&quot;blue&quot;, &quot;red&quot;))(6) P_OK_Pred &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = InRn_Pred, aes(fill = OK_brks, color = OK_brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + scale_color_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + geom_sf(data = InRn_DL, cex = 0.5) + ggtitle(&quot;OK - Predictions&quot;) P_OK_Pred Summarize by grids cells of 10 km x 10 km ## Estimate the mean of the points in each grid cell of 10 km x 10 km ---- # (or municipalities, districts, ...) ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km)+ geom_sf(data = SPDF, col = 2, cex = 0.7) ## Intersect predictions (points - SPDF) and Grid cells of 10km x 10km ---- SPDF_Grids10km &lt;- st_intersection(SPDF, Grids_10km) summary(SPDF_Grids10km) #&gt; IDW_Pred OK_Pred OK_SD OK_RSD #&gt; Min. : 1.13 Min. : 7.811 Min. : 6.45 Min. :0.0569 #&gt; 1st Qu.: 21.34 1st Qu.: 20.840 1st Qu.: 16.27 1st Qu.:0.4345 #&gt; Median : 40.81 Median : 36.673 Median : 22.26 Median :0.6969 #&gt; Mean : 65.39 Mean : 56.319 Mean : 28.59 Mean :0.7145 #&gt; 3rd Qu.: 76.86 3rd Qu.: 67.921 3rd Qu.: 33.67 3rd Qu.:0.9728 #&gt; Max. :1355.53 Max. :594.003 Max. :111.34 Max. :1.7807 #&gt; #&gt; CELLCODE EOFORIGIN NOFORIGIN Id #&gt; Length:4489 Min. :5120000 Min. :3610000 387 : 65 #&gt; Class :character 1st Qu.:5150000 1st Qu.:3650000 388 : 65 #&gt; Mode :character Median :5160000 Median :3670000 390 : 65 #&gt; Mean :5163836 Mean :3674636 446 : 65 #&gt; 3rd Qu.:5180000 3rd Qu.:3700000 447 : 65 #&gt; Max. :5210000 Max. :3730000 476 : 65 #&gt; (Other):4099 #&gt; GID_0 NAME_0 geometry #&gt; Length:4489 Length:4489 POINT :4489 #&gt; Class :character Class :character epsg:NA : 0 #&gt; Mode :character Mode :character +proj=long...: 0 #&gt; #&gt; #&gt; #&gt; Summarize (by Id) SPDF_Grids10km_Sum &lt;- SPDF_Grids10km %&gt;% group_by(Id) %&gt;% summarize(N = n(), IDW_AM = mean(IDW_Pred, na.rm = T), IDW_SD = sd(IDW_Pred, na.rm = T), OK_AM = mean(OK_Pred, na.rm = T), OK_SD = sd(OK_Pred, na.rm = T)) Add values to Grid cells of 10 x 10 km (Grids_10km_Sum) Grids_10km_Sum &lt;- left_join(Grids_10km_Sum %&gt;% as.data.frame(), SPDF_Grids10km_Sum %&gt;% as.data.frame(), by = &quot;Id&quot;) Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% st_sf(sf_column_name = &quot;geometry.x&quot;) summary(Grids_10km_Sum) #&gt; CELLCODE EOFORIGIN NOFORIGIN Id #&gt; Length:93 Min. :5120000 Min. :3610000 340 : 1 #&gt; Class :character 1st Qu.:5150000 1st Qu.:3640000 341 : 1 #&gt; Mode :character Median :5160000 Median :3670000 361 : 1 #&gt; Mean :5163871 Mean :3674516 362 : 1 #&gt; 3rd Qu.:5180000 3rd Qu.:3710000 363 : 1 #&gt; Max. :5210000 Max. :3740000 364 : 1 #&gt; (Other):87 #&gt; GID_0 NAME_0 N.x Case #&gt; Length:93 Length:93 Min. : 0.00 Min. :0.0000 #&gt; Class :character Class :character 1st Qu.: 7.00 1st Qu.:0.0000 #&gt; Mode :character Mode :character Median :12.00 Median :0.0000 #&gt; Mean :10.75 Mean :0.7674 #&gt; 3rd Qu.:14.00 3rd Qu.:1.0000 #&gt; Max. :22.00 Max. :9.0000 #&gt; NA&#39;s :7 #&gt; AM SD GM GSD #&gt; Min. : 2.957 Min. : 0.9767 Min. : 2.061 Min. :1.124 #&gt; 1st Qu.: 18.881 1st Qu.: 19.1492 1st Qu.: 11.320 1st Qu.:2.276 #&gt; Median : 38.933 Median : 39.4056 Median : 24.043 Median :2.753 #&gt; Mean : 69.400 Mean : 67.9795 Mean : 44.716 Mean :2.947 #&gt; 3rd Qu.: 85.645 3rd Qu.: 77.3011 3rd Qu.: 53.733 3rd Qu.:3.437 #&gt; Max. :686.712 Max. :548.5429 Max. :472.351 Max. :6.198 #&gt; NA&#39;s :7 NA&#39;s :11 NA&#39;s :7 NA&#39;s :11 #&gt; MIN MAX AM_brks Prob #&gt; Min. : 0.323 Min. : 5.012 [0,25) :29 Min. : 0.0000 #&gt; 1st Qu.: 1.745 1st Qu.: 58.887 [25,50) :23 1st Qu.: 0.5858 #&gt; Median : 4.233 Median : 131.628 [50,75) : 9 Median : 2.8360 #&gt; Mean : 11.410 Mean : 212.524 [75,100) : 9 Mean : 7.6290 #&gt; 3rd Qu.: 11.316 3rd Qu.: 230.376 [100,200):12 3rd Qu.: 9.7445 #&gt; Max. :143.200 Max. :1615.331 [200,687]: 4 Max. :79.7604 #&gt; NA&#39;s :7 NA&#39;s :7 NA&#39;s : 7 #&gt; Prob_brks N.y IDW_AM IDW_SD #&gt; [0,1) :29 Min. : 1.00 Min. : 8.996 Min. : 1.118 #&gt; [1,5) :28 1st Qu.:38.00 1st Qu.: 25.635 1st Qu.: 10.345 #&gt; [5,10) :13 Median :62.00 Median : 45.840 Median : 17.214 #&gt; [10,20) :14 Mean :48.79 Mean : 66.900 Mean : 30.559 #&gt; [20,30) : 4 3rd Qu.:63.00 3rd Qu.: 84.182 3rd Qu.: 35.327 #&gt; [30,79.8]: 5 Max. :65.00 Max. :424.967 Max. :220.513 #&gt; NA&#39;s :1 NA&#39;s :1 NA&#39;s :3 #&gt; OK_AM OK_SD geometry.x #&gt; Min. : 11.89 Min. : 0.4458 POLYGON :93 #&gt; 1st Qu.: 24.73 1st Qu.: 4.8030 epsg:4326 : 0 #&gt; Median : 37.41 Median : 10.7934 +proj=long...: 0 #&gt; Mean : 56.30 Mean : 17.5544 #&gt; 3rd Qu.: 74.17 3rd Qu.: 19.8067 #&gt; Max. :340.36 Max. :132.7462 #&gt; NA&#39;s :1 NA&#39;s :3 #&gt; geometry.y geometry #&gt; GEOMETRYCOLLECTION: 7 GEOMETRYCOLLECTION: 1 #&gt; MULTIPOINT :82 MULTIPOINT :90 #&gt; POINT : 4 POINT : 2 #&gt; epsg:4326 : 0 epsg:NA : 0 #&gt; +proj=long... : 0 +proj=long... : 0 #&gt; #&gt; Plot maps # Breaks breaks_IDW &lt;- c(0, 25, 50, 75, 100, 200, max(Grids_10km_Sum$IDW_AM, na.rm = T)) breaks_OK &lt;- c(0, 25, 50, 75, 100, 200, max(Grids_10km_Sum$OK_AM, na.rm = T)) Grids_10km_Sum &lt;- Grids_10km_Sum %&gt;% mutate(IDW_brks = cut(IDW_AM, breaks_IDW, include.lowest = T, right = F), OK_brks = cut(OK_AM , breaks_OK , include.lowest = T, right = F)) # Maps P_Grids10km_IDW &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km_Sum, aes(fill = IDW_brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + ggtitle(&quot;IDW - Predictions&quot;) P_Grids10km_OK &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Grids_10km_Sum, aes(fill = OK_brks)) + scale_fill_manual(name = &quot;Bq/m3&quot;, values = cols, guide = guide_legend(reverse = TRUE)) + ggtitle(&quot;OK - Predictions&quot;) # Plot maps grid.arrange(P_Grids10km_AM, P_Grids10km_IDW, P_Grids10km_OK, nrow = 1, ncol = 3) ## Export results to shape file (.shp) for GIS: InRn_Pred and Grids_10km_Sum #st_write(InRn_Pred, &quot;InRn_Pred.shp&quot;, delete_layer = TRUE) # overwrites #st_write(Grids_10km_Sum, &quot;Grids_10km_Sum.shp&quot;, delete_layer = TRUE) # overwrites "],["dose-map.html", "Chapter 5 Dose map", " Chapter 5 Dose map summary(Grids_10km_Sum$OK_AM) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s #&gt; 11.89 24.73 37.41 56.30 74.17 340.36 1 summary(Grids_10km_Sum$OK_SD) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s #&gt; 0.4458 4.8030 10.7934 17.5544 19.8067 132.7462 3 ## New dataframe with AM and SD ---- Dose &lt;- Grids_10km_Sum %&gt;% transmute(Id = Id, Rn_AM = OK_AM, Rn_SD = OK_SD, ) ## Dose [mSv/y] = CRn [Bq/m3] * FE * FO * TY [h/y] * FD [mSv / Bq.h.m-3] # Uncertainty MC simulations nsim &lt;- 100 MC_Sim &lt;- matrix(NA, nrow = length(Dose$Rn_AM), ncol = nsim) TY &lt;- 8760 for (i in 1:nsim) { Rn &lt;- truncnorm::rtruncnorm(length(Dose$Rn_AM), a = 0, b = Inf, mean = Dose$Rn_AM, sd = Dose$Rn_SD) # truncated: Rn &gt; 0 FE &lt;- rlnorm(1, meanlog = log(0.4), sdlog = log(1.15)) FO &lt;- rnorm(1, 0.8, 0.03) FD &lt;- rnorm(1, 9e-06, 1.5e-06) MC_Sim[,i] &lt;- Rn * FE * FO * TY * FD } MC_Sim &lt;- as.data.frame(MC_Sim) MC_Sim$Id &lt;- Dose$Id MC_Sim$Dose_AM &lt;- rowMeans(MC_Sim[,1:nsim]) MC_Sim$Dose_SD &lt;- apply(MC_Sim[,1:nsim], 1, sd) ## Add AM and SD of the MC simulations to the dose table ---- Dose &lt;- left_join(Dose %&gt;% as.data.frame(), MC_Sim[c(&quot;Id&quot;,&quot;Dose_AM&quot;,&quot;Dose_SD&quot;)] %&gt;% as.data.frame, by = &quot;Id&quot;) Dose &lt;- Dose %&gt;% st_sf(sf_column_name = &quot;geometry.x&quot;) ## Dose map ---- summary(Dose) #&gt; Id Rn_AM Rn_SD Dose_AM #&gt; 340 : 1 Min. : 11.89 Min. : 0.4458 Min. :0.2960 #&gt; 341 : 1 1st Qu.: 24.73 1st Qu.: 4.8030 1st Qu.:0.6017 #&gt; 361 : 1 Median : 37.41 Median : 10.7934 Median :0.9095 #&gt; 362 : 1 Mean : 56.30 Mean : 17.5544 Mean :1.4174 #&gt; 363 : 1 3rd Qu.: 74.17 3rd Qu.: 19.8067 3rd Qu.:1.8008 #&gt; 364 : 1 Max. :340.36 Max. :132.7462 Max. :8.6532 #&gt; (Other):87 NA&#39;s :1 NA&#39;s :3 NA&#39;s :3 #&gt; Dose_SD geometry.x #&gt; Min. :0.09389 POLYGON :93 #&gt; 1st Qu.:0.21984 epsg:4326 : 0 #&gt; Median :0.39444 +proj=long...: 0 #&gt; Mean :0.55571 #&gt; 3rd Qu.:0.63535 #&gt; Max. :4.02132 #&gt; NA&#39;s :3 P_Dose_AM &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Dose, aes(fill = Dose_AM)) + scale_fill_gradient(name = &quot;mSv/y&quot;, low = &quot;blue&quot;, high = &quot;red&quot;) + ggtitle(&quot;Radiation dose - AM&quot;) P_Dose_AM P_Dose_SD &lt;- ggplot() + geom_sf(data = Country) + geom_sf(data = Dose, aes(fill = Dose_SD)) + scale_fill_gradient(name = &quot;mSv/y&quot;, low = &quot;blue&quot;, high = &quot;red&quot;) + ggtitle(&quot;Radiation dose - SD&quot;) P_Dose_SD grid.arrange(P_Dose_AM, P_Dose_SD, nrow = 1, ncol = 2) "],["interactive-maps.html", "Chapter 6 Interactive maps", " Chapter 6 Interactive maps library(leaflet) ## Name of municipalities Lithuania &lt;- readRDS(url(&quot;https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_LTU_2_sf.rds&quot;)) p_popup &lt;- paste(&quot;&lt;strong&gt; Municipality: &lt;/strong&gt;&quot;, Lithuania$NAME_2) leaflet() %&gt;% addPolygons(data = Lithuania, stroke = TRUE, weight = 2, fillColor = &quot;grey&quot;, fillOpacity = 0.5, popup = p_popup) %&gt;% addTiles() ## Plot the AM (of the OK predictions) by grid cells of 10 km x 10 km (Grids_10km_Sum) p_popup &lt;- paste(&quot;&lt;strong&gt; Id: &lt;/strong&gt;&quot;, Grids_10km_Sum$Id, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt; AM: &lt;/strong&gt;&quot;, round(Grids_10km_Sum$OK_AM, 2), &quot;Bq/m3&quot;) pal_fun &lt;- colorQuantile(&quot;YlOrRd&quot;, NULL, n = 6) Grids_10km_Sum %&gt;% leaflet() %&gt;% addTiles() %&gt;% addPolygons(# add/remove polygon borders stroke = TRUE, col = &quot;grey&quot;, weight = 2, # set fill color with function from above and value fillColor = ~pal_fun(OK_AM), # make it nicer fillOpacity = 0.8, smoothFactor = 0.5, popup = p_popup) ## Plot the OK predictions by grid cells of 0.01 x 0.01 degrees (InRn_Pred) p_popup &lt;- paste(&quot;&lt;strong&gt; InRn: &lt;/strong&gt;&quot;, round(InRn_Pred$OK_Pred), &quot;Bq/m3&quot;) pal_fun &lt;- colorBin(&quot;YlOrRd&quot;, InRn_Pred$OK_Pred, bins = c(0,50,100, 200, 300, 500, max(InRn_Pred$OK_Pred))) InRn_Pred %&gt;% leaflet() %&gt;% addTiles() %&gt;% addPolygons(stroke = TRUE, col= &quot;grey&quot;, weight = 0.1, fillColor = ~pal_fun(OK_Pred), fillOpacity = 0.8, smoothFactor = 0.5, popup = p_popup) %&gt;% addLegend(pal = pal_fun, values = ~OK_Pred, opacity = 1, labFormat = labelFormat(prefix = &quot;[&quot;, suffix = &quot;)&quot;, between = &quot;, &quot;, digits = 0), title = &quot;InRn [Bq/m3]&quot;) "],["references.html", "References", " References Asch, Kristine. 2003. The 1 : 5 Million International Geological Map of Europe and Adjacent Areas: Development and Implementation of a GIS-enabled Concept. Stuttgart, Germany: Geologisches Jahrbuch SA, Schweizerbart Science Publishers. "]]
